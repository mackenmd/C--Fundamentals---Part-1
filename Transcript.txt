Transcript - English  

An Introduction to C#
Overview
Hi, this is Scott Allen of Pluralsight. And this module was an introduction to C#. This is the first module in a series of modules that will guide you through with the C# language and give you everything you need to know to be an effective and productive C# developer. In this first module, we're going to spend a little bit of time describing the environment that you work inside of. We'll define what exactly the .NET Framework is. We'll also talk about the Framework Class Library which is something that you'll be using when you write your C# program. It's all of the APIs and classes that you can use to interact with the file system in the registry in the network. We'll also talk about the Common Language Runtime which is the environment that your C# program will execute inside of. We'll build our first program, a Hello, World! program. And we'll also talk a little bit about the C# syntax and start talking about some of the expressions and operators that you use inside of a program. We'll be using both command line tools to build our programs and we'll also see how to create a project in creating executable with Visual Studio.
What is .NET?
First, let's define what is .NET. The Microsoft .NET Framework is a generic software framework. That means it's something that your application is going to build on top of. It's the .NET Framework's responsibility to provide all the services that different types of applications will need. For instance, the ability to save information into a database, or the ability to read information from an XML file, cryptography, web applications, numerical algorithms, network communications. These are the type of features and services that .NET is going to provide for you application. And it's a generic framework because you can build a wide variety of applications on top of it. You can build web applications that produce HTML that the user is going to interact with through a web browser. You can also write desktop applications that draw buttons on the screen that a user can click. You can also write Windows services that might run on a server in the background and the user doesn't interact with them directly, but they can do batch processing and they can monitor directories and process files when they arrive. When you're writing an application in C#, your application is going to be running on top of the .NET Framework. That does mean that the .NET Framework has to be installed on the computers where you want your software to execute. It's very easy to download and install the .NET Framework. Some of the most recent releases of the Windows operating system already have .NET installed, so Windows Server 2008, Windows Vista and Windows 7, they all come with the Version 3 at the .NET Framework. That's not necessarily the latest version that you might want. So even on those operating systems, you might need to go out and download and install the latest release of the .NET Framework. Now, the framework itself, we commonly think of it in two separate pieces. There's the Common Language Runtime or the CLR, and the Framework Class Library or the FCL. Some people also refer to this as the Base Class Library, or the BCL.
What is the CLR?
The Common Language Runtime is an execution environment for your .NET applications. That means it is the CLR that is responsible for bringing your application to life and managing it while it executes. And it's also the Runtime's job to tear down your application when it's finished executing, or if it has an unrecoverable error. Here are some of the services the CLR provides when it is managing your application. One is memory management. So the CLR is actively tracking all of the objects and all of the memory that you are requesting to do work. And it knows when you are finished with those objects and when you are finished with that memory, and it will clean things up for you so that your program continues to have enough memory as it keeps executing. The CLR is also responsible for security. There are some scenarios where your application has to operate inside of a very strict sandbox, so it's not allowed access to certain areas of the file system. It's the CLR that is going to enforce certain security policies on your application. The CLR is also going to make sure that your application doesn't try to read or write memory that doesn't belong to your application. In many ways, the CLR is like a virtual machine. It virtualizes your execution environment so you do not need to worry about what version of the operating system that your application is executing on. You don't need to worry about the specific CPU that has installed on the machine, or how many course it has, or what instruction set is available. The CLR will take care of all those things and make sure that your application executes correctly. We call it the Common Language Runtime because the CLR is independent of the language that you use to write .NET applications. You can write them in C#, but you can also write them in Visual Basic or F#, or IronPython or IronRuby. Those are all .NET applications. They're all going to be managed by the same CLR. The CLR is available for pretty much every version of Windows since Windows XP. It also runs to a mobile phone such as special version of the CLR. It's not the same version of the CLR that run to the desktop machine. And there's another special version of the Common Language Runtime that is used by Microsoft Silverlight. Silverlight applications run inside of a web browser and that version of the CLR will work on both Windows machines and also on Apple machines that are using Intel CPUs.
The FCL
While the CLR works in the background to manage your application, it's the Framework Class Library that you'll be using on a day to day basis. Because it's the Framework Class Library that contains thousands and thousands of classes that you use to build applications. It provides you all the functionality to do things like parse text and use regular expressions. One part of the Framework Class Library is Windows Presentation Foundation that allows you to create applications that run directly on the user's desktop. Another part of the Framework Class Library is ASP.NET that allows you to create web applications that an end user would have to use a browser to interact with. You can also use classes in the Framework Class Library that are part of Windows Communication Foundation to write web services that allow computers to communicate. The Framework Class Library is so large and so varied that it's very rare for one person to know all the ins and outs of the entire library. Typically, you're going to focus on just a couple pieces and master those and build applications with the specific pieces that you need that fit your business.
Hello, C#
Let's turn our attention to the C# language. C# is a standardized language for creating .NET components and applications. It's a standardized language because Microsoft took the specifications on the syntax of this language and the semantic rules for interpreting it, and registered them with ECMA International. ECMA is an internationally recognized standards organization. You can come to the ECMA website and you can download the C# standard that's known as ECMA-334. It's actually a really good read once you become more familiar with the C# language. This document can give you the really nitty-gritty details of a language and you can discover some of the more subtle features of C#. As I mentioned previously, you can use C# to create any type of .NET application. You can create applications and services and also reusable libraries. That is, you can package up code to use across multiple applications by creating a library. The syntax was inspired by C++ as was Java syntax. So all three of these languages look somewhat similar. Here's a snippet of a C# code that is defining a method called Main. A method is a place where you can organize your code and you can call a method to force the code inside of that method to execute. The code inside of this method is using the DateTime class to find out what the current day of the week is. When this program is executing, what is the day of the week? If that day of week is equal to Monday, and we'll check that by using a double equal sign, so if the current day of the week is Monday, then we will branch inside of this if statement, so we'll execute the code inside of the curly braces. Inside of here, we're calling another method, WriteLine. This method is attached to a Console class. So Console.WriteLine is forcing WriteLine to execute and we're passing it some data. We're passing it a parameter. We're passing it information that is going to write onto the screen. In this case, it's just going to write out the text, "Another case of the Mondays!" And again, that only happens on a Monday. If the current day is not a Monday, we don't execute the code inside of here. We just come straight down here to the bottom where the method will simply exit and return without writing out any information to the screen.
Command Line Demo
Let's create our first C# program. And instead of using Visual Studio, I'm going to use a very simple tool so you can see what's happening behind the scenes. I'm going to use a command line prompt and notepad and create a file called hello.cs. .cs is the file extension that you want to use if you're creating a file with C# source code inside of it. And the first line I'm going to put in here is a using System. This is telling the compiler that I want easy access to some functionality that is inside of the system namespace. Everything in the Framework Class Library is partitioned into a namespace. For instance, if you're writing web applications with ASP.NET, chances are, you'll be using system.web. So that contains a lot of functionality that's used by ASP.NET. We don't need that, but we do easy access to some stuff that is inside of the route system namespace. The next thing I'll do is create a class because you'll-- one of the things you should know about .NET is that anytime that you're going to create code that wants to execute, that code has to be attached to a type. It has to be defined inside of a type. And one way to define a type is to create a class. In this case, we have a class called Program. Everything between these curly braces is going to be a member of that class. Now, I'm going to create a method. And we'll talk a little bit about what these other keywords are in later module, public static void. That's just a way of describing some of the characteristics of this method. The most important thing right now to know is that this is a method called Main. It takes no parameters. And the body of this method, that is the code that I can put in it, is also going to be between curly braces. Inside of here, I'm going to use that console class again. It has a method on it called WriteLine. And I can tell it to write to write out to the console Hello, World! And I'll save that. At this point, I don't have anything that can execute. I just have a text file. So I'm going to go to the C# compiler and transform this into something that can execute. One way to run the C# compiler is to go to the framework installation directory which for version 4 will be under your Windows directory in Microsoft.NETFramework. And then, you can have multiple versions of .NET installed. In this case, we're going to the version 4 directory. Inside of there, there will be an executable called csc.exe. That is the C# compiler. And in this case, it tells us we have an error. We didn't specify any inputs. So let's try it again and actually tell it to compile hello.cs. We didn't get an error message this time. If we look at the directory, you'll see we have hello.exe. So this is something that we can actually execute. And it writes out Hello, World!
Command Line Compiler
Let's do a quick review of what just happened. We used the command line compiler, csc.exe. We can pass multiple files to csc.exe. When we wrote our Hello, World! program, we just passed one file but you can-- if you have-- when you start building bigger applications, obviously, you don't want all of your code inside of one file. You can spread it across multiple files, pass them all to csc.exe and it can produce a single executable, or a shared library out of all those files. Technically, what the C# compiler is doing is it's taking your C# code and it's transforming it into something called Microsoft Intermediate Language. Some people will refer to this as MSIL for short or M-S-I-L. Microsoft Intermediate Language is instructions for the CLR. It's the CLR's job then to read those instructions and transform them into instructions for the CPU that is on your machine. So the processor in your computer by itself cannot execute a .NET application inside of an exe. You need to have the CLR, the Common Language Runtime to take the MSIL that's inside of an executable or inside of an assembly is technically what we call these artifacts that are produced by csc.exe, to take those instructions inside of an assembly and transform them into native code that runs on the real hardware that you're operating on.
Visual Studio Demo
Let's build our C# application again, but this time, we'll be using Visual Studio. Anytime you're going to create a new application in Visual Studio, you want to go to the file menu and select new project, or new website if you're creating a website. We're going to choose project. Inside of this new project dialog, there will be categories for all the different types of applications you can create with Visual Studio. So you can create Silverlight applications, workflow applications, applications that run inside of Microsoft Office. I'm going to select the Windows category because that's where we're going to find console application. Down here, I can give my console application a name. We'll call this HelloWorldVS for Visual Studio and it's going to be located in the temp directory. Once I click OK, Visual Studio comes out and creates a number of files for me to get started. So this is Program.cs. This is the source code for my application, everything I have so far. We already have some namespaces that are included for us. These are commonly used namespaces that you will be seeing in .NET quite a bit. We don't need all these namespaces for this simple application, but we'll leave them in place. This is an example of putting our code inside of our own namespace. So by default, our top level namespace for the class that's in Program.cs is going to be inside of a namespace called HelloWorldVS. We have our program class and inside of our program class is our Main method. One difference here compared to the program that we wrote from the command line is that this Main method takes a parameter. It's an array of string called the args. It's an array because of the bracket characters that are here. I'll show you how to use that in just a bit, but for now, we'll go ahead and put in our Console.WriteLine, let's say Hello, World! And then we'll put in a Console.ReadLine. That's going to force someone to press a key before the program can exit. So it's going to be stuck on this line until it can read something from the console. Before we go to run this, I want to point out a window here inside of Visual Studio. It's the Solution Explorer window. The solution that we are working on is called HelloWorldVS. And there is a solution file on this that can organize one or more projects. So on very large applications, you can have multiple projects inside of the solution. So I can come in, I can say add new project, create another console application or maybe a class library that's going to have some reusable code that I share across multiple projects in the solution. And I can break large applications up into multiple projects to make it easier to manage and work on. We're just building something simple. So we're going to stick with one project that's called HelloWorldVS. That's the project. And what a project can do is manage multiple assets to build a single assembly, so to build a single exe file or single library, a dll file. As we get further into this course, we'll find that we need to add multiple .cs files into a project and that's very easy to do. I can come in and I can say add class and Visual Studio will create another .cs file for me. So in this case, it's just called Class1. In large applications, what people typically do is they will create folders and organize their classes into different folders. So let's just call this folder Logic and I'll put Class1 inside of Logic for right now. We're not actually going to do anything with the Class1. It's just going to sit there in our project and be empty and not do anything. But I'll show you how the-- what you see here in the Solution Explorer window is going to be mimicked on the file system. So let me take the Solution Explorer window and dock it back over here on the right side. And now, I'm going to come to the build menu. When I tell Visual Studio to build a solution, what it does is go through each project that is inside of that solution and tell-- in turn, tell that project to build. And the project can then invoke the C# compiler or the Visual Basic Compiler and pass all of the assets in .cs files that are inside of the project to the C# compiler to have it produce a library or an executable. Let's go ahead and do a build and we'll get an output window. Let me show you this. This is the output from the C# compiler. So it tells us that it was able to build this project, nothing failed, nothing was skipped, and it even shows us where to put the output. So the output went to HelloWorldVS.exe and that's underneath of my temp directory. Let's go out to the command line and take a look at this and run it. So one of my temp directory there is HelloWorldVS. Inside of here, you'll find a .sln file. That is the solution file. There's information inside of that file to-- textual file, information inside of that file about what projects are included in this solution. Then typically, you'll find a subfolder for each project that is inside of your solution. So if I go and change directory into HelloWorldVS again, this is my project directory, it's inside of here where I will find the .csproj file. That's the project file in my Solution Explorer window. The .csproj file is an XML file that has a list of all the .cs files in my project and other settings that I need to build my application. You'll see Program.cs is inside of here and there's also a directory called Logic. So that's mapping directly to the Logic folder that we created here. If we go inside of Logic, there's Class1.cs that we had added to our project up here. ( Pause ) Now, by default, when you are creating projects inside of Visual Studio and telling them to build, the executables don't get built into the route directory. They get built into a subdirectory. In this case, we have to go in to the bin directory for binaries and you can build things in debug or release mode. So, release mode builds are made for production applications that need to run very fast, debug mode builds are the ones you'll have by default. They have a number of flag set that make it easier to step through with a debugger and find problems in your application. Let's move in to the debug directory. And here is where we find our executable, HelloWorldVS.exe. There's also some other files in here that facilitate debugging, but we can run our program. And it will say Hello, World! and then wait for us to press another key before it exits. Before we leave this example, let's do one more thing. I'm going to come back into Program.cs and I'm going to read one of the entries that comes in through this args parameter. For console mode applications, this args parameter represents parameters that were passed on the command line. In other words, if I type in HelloWorldVS.exe Scott, that text Scott should be passed into my program as the first argument. Let's see if we can do that. I'm going to create a local variable called name. Into that, I will assign the first element in the argument array. So arrays and C# are zero-based. The first element is in index 0 and you index into the array using the square brackets. And now, I want to write that name out. There's a couple of different ways I can do that. One is to simply take that string Hello and a comma, and then add this name. The addition operator, when applied to strings in .NET, will simply concatenate two strings together. This isn't always the most performant way to put strings together, but it's very simple and it's going to work for our application. Every time we make a change like this, we need to come up and do a build so that all of the latest code is compiled into our executable file. And now, let's try to run HelloWorldVS and pass in Scott, and we get Hello, Scott. Press another key, and our program is finished.
The IDE
The tool we used to Visual Studio is an integrated development environment or an IDE. The goal of an IDE is to put together all of the tools and functionality that you need to build an application into one place to make it very easy to get to the things that you need to do. Visual Studio comes with a tremendous number of tools, but some of the obvious ones are an editor, so you can edit C# files inside of Visual Studio. You can also edit Visual Studio basic and configuration files and XML files. Visual Studio knows how to run the C# compiler, or more importantly, it knows how to instruct projects to build themselves and then it's the projects that can in turn run the C# compiler. And that means you can have a C# project and a Visual Basic project and an F# project all inside of the same solution. Visual Studio knows how to delegate the work to get those things to build and produce the assemblies that you need for your application. There's also a debugger inside of Visual Studio. So if something isn't working right in your application, you can press F10 and step through the code inside of your application line by line and inspect the variables and see what their values are, and see what each statement and expression in C# is doing. There's also a variety of testing tools inside of Visual Studio. There are unit testing tools that let you exercise your code and see if it produces the expected results. In some versions of Visual Studio even let you test web applications, so that can automate the sending out of network request and processing the response and making sure that it sees the expected HTML. You can spend quite a bit of time just finding and figuring out how to use all these different features inside of Visual Studio. My suggestion is always to start with a text editor and find out what it can do because it's usually the text editor where you're going to be spending most of your time.
Solution Explorer
I also wanted to review the Solution Explorer window because this window is very important. If you're ever in a situation where you cannot find the Solution Explorer window or it's not open, just remember that you can always come to the view menu and click on Solution Explorer. That will reopen the Solution Explorer window for you. The Solution Explorer window always contains at least one project but you can have multiple projects inside of here as I mentioned before. And then each project in turn is going to contain one or more source code files. So .cs files. All of those files will get complied together when you do a build to produce an assembly. And again, an assembly can be an exe file that runs by itself, or it can be a library that doesn't execute but you can load that library into other executables when they run and that's the way you can share code. Pretty much any real world business application that you're going to build that's not a simple prototype of a very trivial application is going to consist of a solution that has multiple projects underneath of it. What you need to do for each application is figure out how to break it into these multiple projects in the way that makes sense for the way you work and the way that your team works, and perhaps, even how you distribute your application.
Types
I've already mentioned the concept of types several times in this introduction. Types are very important because C# is what we call a strongly typed language. Everything that you interact with from a C# application has a specific type. And the C# compiler knows what that type is. It's going to allow you to do certain things based on type information. It's also going to throw errors if you try to do something that's not allowed with a specific type. So for example, when I declare a local variable, like this name variable that I assign it a value, I have to give this variable a type, a specific type. In this case, the type of this variable is string. It can hold a sequence of characters. This allows me to take text that someone typed into the command line and that came in through the argument parameter, and assign that into name so that I can use it later inside of this method. I can create another variable and give it a different type. So now, I have a variable called result and it's of type integer. It can hold things like integers. So I could say result equals 4. I could also say result equals 4 divided by 2. And then we could write that result out to the command line. Let's build this application and run that real quick. Build succeeded. And there you can see we got our 2. 4 divided by 2 is 2. ( Pause ) But, what if I tried to do something like take 4 divided by name? And you might think, well, maybe that's possible. If someone were to type in a 3 here, then what my program should do is take 4 and divide it by 3. But that's not going to happen. In fact, we're not going to be able to build. We're going to get an error. If we look at the output window, then you see that we're getting an error. Compile complete, 1 error, 0 warnings. It wasn't able to build our application. Another window that you might come across quite frequently is the error list window. This will describe all that errors that the C# compiler found inside of a program. So this is very explicit. It says that division operator cannot be applied to operands of type 'int' and 'string'. It doesn't make any sense to try to take an integer value like 4 and try to divide it by a string. A string is supposed to hold textual information. If you double click one of the errors inside of the error list, Visual Studio will take you right to the piece of code that is causing that problem. And you can even find many of these problems before you do a build because Visual Studio will put little squiggly lines under problems that if finds as you're typing. And if you place the mouse over that, hover over it, you'll get the error message as a pop up window. You can define your own types using C#. In fact, when we wrote our class program, that was defining a new type. The type's name is program. Everything that you work with from C#, every object that you touch, anything that you assign or declare is a variable is going to have a specific type. There are thousands and thousands of types already built into the .NET Framework. We'll see what a few of those are in just a bit. But when you're building your own application, the trick is really what custom types do you want to create and what are they going to represent. You'd might need a type that represent a costumer or a type that represent a product or an account. Those are all going to be types that you define that have their own methods and then you can use them in your C# code. All of the code that you're going to write that's going to execute and do thing like write to the database or read XML files, all of that code has still live inside of a type. Typically, code is placed inside of a method like the Main method that we wrote earlier, but we'll explore some other things so you can add to a type as we work through this course.
Primitive Types
Here are some of the primitive types that are built into the .NET Framework. We call these primitive types because they really are the fundamental lowest level building blocks that are available in .NET. These are the atoms of the universe that you're going to put together to build bigger molecules for your business application. One primitive type is the 32 bit integer. You can declare a variable of this type using either the int keyword that C# recognizes or Int32 which is the proper type name for a 32 bit integer in the base class library. Let me show you that these two are really interchangeable. So here where we say int result equals 4 divided by 2, I could've also said this is an Int32. ( Pause ) And the C# compiler would've been happy with that too. Another one is a long which is a 64 bit integer or Int64. You can represent true or false values using a bool type in C#. There's single precision floating point and double precision floating point. Those are floats and doubles. There's a fixed precision data type known as decimal which is something you will typically want to use in financial calculations, because it's not going to circum to some of the floating point lousiness that you might experience with float or double. There's a DateTime data type to represent dates and times. It has a resolution of 100 nanoseconds. And then there's string which we've already used also that represents text, a sequence of Unicode characters.
Namespaces
The thousands and thousands of types that are in the .NET Framework are all organized into namespaces. You can think of them as bins where types get placed into to give them a logical organization. For example, if you look at types that are defined inside of the System.Net namespace, you'll find types that are related to network communications. So, socket types and things that deal with PCP/IP addresses and DNS lookups. Namespaces also help us avoid type name collisions that's for-- I create a class called costumer and you create a class called costumer, and it turns out we can still use those easily inside of the same application as long as we put those in different namespaces. You can define your namespaces for your types in one or more places and the way you do that is by using that namespace keyword that we saw here. So the-- in this example, program is inside of the namespace HelloWorldVS. Int32 is a built in type. It's actually in the system namespace. And there's two ways that we can refer to this type, Int32. If we want to declare a variable type Int32 and we do not have a using clause here, you'll notice that we get errors for Int32 in Console. All of a sudden, the C# compiler doesn't know what these things are. We could tell it, we want a System.Int32 and a System.Console. Now, it knows exactly what types we're dealing with. We can build and still get a successful compilation. What this using keyword is really doing is telling the C# compiler, go ahead and look through all of the types that are defined inside of the system namespace when you're trying to resolve what an Int32 is. So we don't need to include System.Console.WriteLine. We can just say System-- or we can just say Console.WriteLine and Int32. Many times, particularly when you're creating configuration files, you have to deal with what we call fully qualified type names. A fully qualified type name includes all of the information that the CLR needs to locate a type. That includes not just the type name like Int32, but also the namespace that that type is inside of, and the assembly or the code for that type lives. Let's take a look an example. Let me take this result and what we're going to do is write out the fully qualified type name of Int32. Actually, what we're going to do is we're going to walk up to result and there's a method on every object in .NET called GetType. We're going to invoke GetType and that gives us back the type information for that object. And one of the things we can look at in the type information is the assembly qualified name. That's the same as the fully qualified name with this type. We're going to write that out. So let's do a build. Every time we change a program, we want to make sure we do a build. And let's run the application. And the fully qualified type name is System.Int32. So that's namespace, the type name, and here's the assembly, mscorlib. So on disk somewhere, there is an mscorlib.dll. This is what we call a strongly named assembly because it has a version. It can be picked up for a specific culture, and it's crypted graphically signed so that we know it's not tampered with. So the assembly name includes a PublicKeyToken. We can use that to verify the integrity of that assembly. And as I mentioned before, there is a using directive. This brings a namespace into scope so that when we're using a type like Int32, we don't have to namespace qualify it. We don't have to say System.Int32. We can just say Int32. So it's going to be quite common at the beginning of each of your .cs files you're going to have a number of using keywords that bring namespaces into scope that you're going to be using inside of the code that's in that file. And these could be namespaces that are defined by the .NET Framework Class Library, that could also be namespaces for classes and types that you have defined that are perhaps were in the same project but maybe they're even in a different project, a different assembly, and it can also be other third parties.
Variables
Variables in a C# program are those named pieces of information that you create to hold some value. In this code snippet, we have a variable called answer that's holding the value 42 and a variable called name holding the string value of C#. Variables always have to have a type. So I had to declare that answer was an integer and that name was a string. One rule with variables in C# is that you always have to assign a value to a variable before you can begin to use that variable. In other words, if I tried to get the C# compiler to use a variable called x in a calculation, before I've given a value to that variable x, I'll have a warning that I'm using an unassigned local variable. To get this program to compile, I would have to initialize x with some value. And it doesn't have to be what we call a hard coded value like what I'm doing here, giving it an explicit value. What I could put in x is the result of some other calculation perhaps and then use it again later in the method. As I mentioned previously, C# is a strongly typed language. That means that the compiler is going to make sure that types are compatible when you're performing operations on them and making assignments. If I tried to take answer which is an integer and assign it to name which is a string, I'll have another compiler error. And the C# compiler will tell me, I cannot implicitly convert this 'int' into a string.
Statements and Expressions
Two more important concepts in C# programming are the concepts of statements and expressions. A statement in C# is an instruction. It's something you want the program to do to perform some work. When we create a method like this Main method that we've been working with, this is a series of instructions, write a line, write a line, read a line. One of the distinguishing characteristics of a statement in C# is that all statements end with a semicolon. And statements are executed in the order in which they appear in your source code. For instance, this bit of logic, program execution is going to move from top to bottom, first we'll take an order, then will package an order, then we'll ship an order out. Those are all method invocations, recalling methods just like Console.WriteLine or Console.ReadLine, but these would be other methods and we're invoking those to perform work, and those are statements. An expression, on the other hand, is a fragment of code that is going to be evaluated to produce a value. So for example, this literal value 5 is an expression, it produces the value 5. Same scenario for this value 10, it's going to produce the value 10. x plus y is an expression that's evaluated. There's an operator in between those two, x and u, the addition operator. But in this snippet of code, that expression is going to be evaluated to assign the value of 15 into answer. So quite often, you'll see expressions that are using operators, addition, subtraction, maybe boolean operators that are testing true or false. But you can also have expressions just with literal values, numerical values or string values. And quite often, we're using expressions to produce some new value that we're going to assign to a variable and then use that in further calculations. Or sometimes, we might just use an expression to test some condition if answer is less than 20 or if answer is greater than 10, or if the current time of day is after 3 p.m. Those would all be the common types of expressions that you'll see in a C# application.
Operators
Here are some of the common operators that you'll run across in everyday C# development. You'll see mathematical operators like addition, subtraction, multiplication, and division. There's also a set of relational operators to establish a relationship between two variables. So for instance, we can ask, is x less than y? Is x greater than y? Is x less than or equal to y? Or is x greater than or equal to y? There are also dedicated operators to test for equality. So a two equal signs put together is a test for equality between two values. So, is x equal to y or is x equal to 5? And there's also the inequality operator, exclamation point and equal sign. And make sure that you're using two equal characters because a single character means assignment. This is assigning the value 5 into x. This is assigning the value 10 into y and then we're performing a test. If x is not equal to y, then perform this action. Else, if x is equal to y, we'll perform this action. There are also some special assignment operators. Let's look at some code and I'll give you demonstration on this. Let's say that I wanted to add the value 5 to x. One way to do that would be to say x equals x plus 5. So I have an expression, x plus 5, that should produce the value 7. The value 7 will then be assigned into x. It will now the value 7. A shorthand way to do this is to use a plus equals operator. So with plus equals, you don't need to put the x over here. What the C# compiler sees is that you want to take the value 5 and add that to x and assign it back into x. This statement will be taking x and multiplying it by 5 and assigning that back into x. So after that statement executes, x should have the value of 10. It will be 2 times equals 5. There's another special operator that's assigned to just increment x. That is, add 1 to x. Instead of saying, x equals-- x plus 1, and instead of saying x plus equals 1, what we can say is just x plus, plus. And the C# compiler knows that it's supposed to increment x. x should have the value 3 after that statement. And in fact, that's what we were doing back here in this snippet of code. If x is not equal to y, and this will evaluate to true because x is 5 and y is 10, then we'll enter into this piece logic and that'll add 1 to x, so x will have the value 6. Otherwise, if in a different situation where we initialize these variables differently, x was equal to y, we would add the value x into y and assign that the result of that computation into y.
References
One more concept I wanted to tell you about before we left this introductory module is the concept of an assembly reference. Now, we've already talked about assemblies and we've talked about how when we do a build in Visual Studio, each of the projects that is in our solution is going to build into an assembly. So an assembly is a container. It contains all of the types that we've defined and all of the code that we've written. It's inside that assembly. If someone else wanted to use the functionality that we've created, we'd have to give him that assembly and they'd have to add a reference to that assembly into their project that gives them access to all the things that we've written inside of there. The Framework Class Libraries themselves are broken up into several dozen assemblies. They contain all the features that Microsoft has given us to use with .NET. But we don't have a reference to all of the assemblies that makeup the Framework Class Library in our project. A project typically is only going to start with the bare minimum number of assemblies that it needs to get started with. And then as you add functionality and branch into different areas, chances are, you're going to need to go out and add a reference to other Framework Class Libraries to those assemblies, or maybe to a third party assembly that someone else has written. It's also quite common in a large solution that is made up of many projects that you need to add references between projects inside of your solution so that you can share code between projects. One easy way to see what is inside of the assemblies that you have referenced is you use a tool called the Object Browser. Let me bring up the Object Browser in Visual Studio. It's under the view menu and select Object Browser. What we have here is a list of all the assemblies that are currently referenced by our project and the assembly that's going to be produced by our project itself. You can also see these references in the Solution Explorer window under that references tab. If you open that up, you can see we have a reference to the system assembly, to the System.Core assembly, and to the System.xml assembly and a few others. Every .NET application is also going to have a reference to mscorlib that is just sort of implied. That is the bare minimum that you need to be executing .NET code. If we clicked to expand this, this is a tree view, what we're seeing now is all of the different namespaces that are inside of this assembly. So there's a System.IO namespace, and there's also just a System namespace. In our application, in our assembly, we have a HelloWorldVS assembly that has a HelloWorldVS namespace. In there, you can see our Program. That's where our Main method was. So this middle widow here is going to list all of the methods that are available on this type, this class called Program. In here was Class1. That was the empty class that we just added to demonstrate how Visual Studio maps things to the file system. Let's go back to the system namespace and mscorlib and open that up and see what's inside. One thing you can find in here is the Int32 and Int64 types. And you can see all the methods that are available on those. You can also find the console type that we were using. ( Pause ) And inside of here, you can see that console has a ReadLine method. That's the method that we were invoking to read a key, a line from the console, so that someone had to type something before our program would exit. And you can see there's an extensive number of types just inside of the system namespace of mscorlib and there's a couple dozen namespaces inside of here that you can browse. And by the time you go to the entire Framework Class Library, again, you'll find thousands and thousands of types. If you want to get to some of these other types and the functionality that they offer, you can right click on that references node and then select add reference. This dialog box will allow you to reference another assembly. You can reference assemblies produced by other projects that are inside of your solution. We don't have any other project, so this tab is blank when we look at it. You can reference COM components that are installed in your system. You can browse to an assembly if you know exactly where it's located on disk. And you can also look at the Standard.Net assemblies that are installed on your machine. So there's PresentationCore which is part of the Windows Presentation Foundation framework. Here are some assemblies for interoping with Microsoft Office. That is working inside of Office applications or all the meeting Office applications. And you can see there's a huge number of assemblies listed inside of the add reference dialog. And you can click to sort them by name or by path. Typically, you'll want to sort them by name. And it's quite often that you want to go to one of the system assemblies to find functionality you're after. Those are the most popular assemblies. For instance, here is System.Configuration for working with configuration files in .NET. System.DirectoryServices to talk to an LDAP server that might be on your network. Further down here, we'll find System.ServersModel which is part of Windows Communication Foundation which allows you to build distributed applications. It is that add reference dialog then that is your gateway to functionality that's been built by Microsoft or built by other vendors or other teams that are inside your company. And as soon as you add a reference to that assembly in your project, you can begin using the APIs and the types that are defined inside of there.
Summary
This concludes our introduction to the C# programming language. We've seen that C# is just one of the many languages that you can use to target the .NET platform and write applications that run on top of .NET. We also talked that there are languages like F# and Visual Basic and IronRuby and IronPython, but it's C# that has a syntax that is very similar to C++ and Java. So if you come from a C++ background or a Java background, the syntax with the semicolons and the curly braces and using a dot to invoke a method, that should all be very similar, very familiar to what you've done in the past. I demonstrated how C# was a strongly typed language. Whenever you declare a variable that's going to hold a value, you need to declare the type of that variable. And then the C# compiler is always going to be checking to make sure you perform legal operations on that type and that you're not trying to assign incompatible types. We talked briefly about the difference between statements and expressions and how statements end with a semicolon while expressions are used to produce values. Sometimes an expression is just a literal value like the number 5 or the string Hello. Other times, you can use an expression in combination with an operator to produce a new value and do something like addition or test for equality. Finally, we saw how assembly references are how you gain access to additional functionality that someone else has written and packaged into an assembly. So an assembly is a container that has types inside of there, it has compiled code inside of that assembly. And if you want to be able to use that in your application, one way to do that, the most common way to do that is to directly add an assembly reference to that file.
Classes and Objects
Introduction
Hi. This is Scott Allen of Pluralsight. And in this module, I want to teach you about classes and objects. We'll be looking at the difference between a class and an object, and talking about some of the specific features that you can add to a class like constructors. We'll also look at some of the features of the C Sharp Programming Language that make it an object-oriented programming language, the ability to use inheritance, the ability to encapsulate state, and the ability of objects to have polymorphic behavior. We'll talk about access modifiers and also look at some of the keywords that you'll be using when you're defining a C Sharp class, with the abstract key word, the static keyword, the sealed keyword, and the partial keyword.
Classes and Objects
When you write a class in C#, you are defining a type, and we know from the last module that types live inside an assembly and types are something that .NET knows how to work with. And when you write this class, you're probably adding properties and fields that represents the data, objects that that type can hold or the state that an object can hold. And you're probably, also adding methods to that class, the methods represent the behavior that the object will exhibit when you invoke a method on that object. Another topic that we'll touch on more later in this module is, you can define the accessibility of the type and its members. It's possible in C Sharp to write a class that only other pieces of code inside the same project can use, we don't want to expose that to other clients. You just want to use it internally. The reason you're defining a type is that you want to use that type to construct objects. In this way, a class definition has a lot like a cookie cutter. Here we have a large pile of dough that doesn't really have a shape but using this squirrel-shaped cookie cutter, we can create as many cookies as we like and they're all going to have a consistent shape, they're all going to look like the squirrel, you can think of the dough as memory on your computer and the cookie cutter as a class definition. You can use that class to stamp out objects that are going to lived in memory. And each object that you can create will hold-- can hold different pieces of state. So let's say I have an employee class with a name field, if I create three instances of that employee class, each instance can hold a different value for the name field. But each instance is going to have the same behavior if I define any methods on that employee class, all the objects will respond to the invocation of that method in the same way.
Demo in WPF
Let's jump into Visual Studio and create a new class. We know that we need a project for our class to live inside of. And this time, instead of creating a console application that just runs on the command line. Let's create a WPF Application, a Windows Presentation Foundation application. This is a window that will run on the user's desktop. Visual Studio will create everything I need to get started, giving me a few files, I'm going to go ahead and press F5 to run this project in the debugger, and you'll see that we get a big blank empty window. We can change that easily. Now we're going to focus on classes and not so much on WPF, but I'll show you just a few things. This is a design surface, if I open up the ToolBox, I can find a lot of controls that I can put on that design surface. I'm going to create or take a TextBlock from the ToolBox, click and drag that here on the design surface. And that gives me a place where I can display text, display a string. On the lower half of the screen here is the XML representation of this UI. This is an XML in a specific dialect called XAML, Extensible Application Markup Language. And there's our TextBlock element that puts the control on the screen. I just want to change the name of it to output, we'll see how we can use that later. Now let's come back to the project, right click and select add a class. Generally speaking when you're working on a .NET Project, and you want to create a class, you're going to put that class in its own file with the same name as the class. We want an employee class so I'm going to create employee dot CS, click add that gets added to my project. And now I can introduce some states. So I can say public string name. That is a field that's on my class. If I actually want to use that, then I could write some code inside of this class which is the code behind from my windows. So this executes when the program runs that windows shows up on the screen. Now, I'm not going to be able to say, employee dot name because name is a field, it's not associated with the employee class, it's associated with an instance of that class. So it's construct an instance, we'll call it e1 and we'll use the new keyword to tell C Sharp that we want a new instance of employee. So we'll pick up this cookie cutter and stamp out a new employee object that will allow us to say e1.Name equals Scott. And if I want to show that, I can walk up to that TextBlock that we put on the screen. Remember, we named it output you see that's available to me here. And it has quite a few-- and it has a lot of properties that we can set, but the one that we're interested in is the text property. This is the text that we want to display on screen, so we'll say that that equals e1.Name and let's run this program, and you'll see that we get a Scott on the screen, here we go. So let's close that. I told you, you can construct multiple instances of an object and that's certainly true. So I can say, employee e2 equals a new employee. And this employee's name is Poonam. And then for the output, let's concatenate some strings. So I'm going to say e1.Name and then add a space plus e2.Name, and we'll run this program again. And you see we get Scott and put it on the screen.
Constructors
When we used the new keyword on that last example, what we were really doing wan invoking a special method on our class that is a constructor. We didn't have to explicitly write a constructor for our class, there was one provided for us by default. But there are many cases where you will want to write a constructor. A constructor is where you can set up the default values for your object. In some scenarios you might even write multiple constructors. This will allow people to use the constructor that best fits their scenario and instantiate the object and have it initialized appropriately for how they want to use it. When you write multiple constructors, each constructor method must take different types of argument or a different number of arguments for the C Sharp compiler to be able to figure out which constructor to call. The snippet of code that is on the slide is defining a constructor for the employee class. I know this is a constructor for two reasons. First of all, a constructor never specifies a return type. Any other method that you write on a class has to specify that it returns an int or a string or some type or you can use the void keyword just to specify that the method doesn't return anything. But a constructor never has any type information, never has a void keyword here. The other way that I can tell this is a constructor is because it exactly matches the name of the class, class name is employee, this method name is employee, I know it's a constructor. And what it's going to do is simply setup the state or properties and fields that are in this object to some default values. Name equals empty and salaried equals false is what the client is going to see after they construct an object of type employee. With that in mind, let's switch over into the demo application and I want to make a quick change here. First of all, where is this code? What sort of method is it in? It's in the constructor for the main window that pops up on the screen. Now generally speaking, you don't want to perform any work inside of the constructor of a WPF window or WPF control. The constructor is really where it needs to initialize itself and get itself ready to display on the screen. After, everything is going to initialize, it's been loaded up and it's on the screen, you'll get an event that signifies that everything is ready and you can hook into that event and execute some code. We're going to be talking about events in more detail later in this course, but for now, just trust me that MainWindow underscore Loaded is an event handler, this method will be invoked by WPF once the window is on the screen and everything is ready to go. And it's inside of there, where we going to execute our code and change the display of the output TextBlock. The other small change that I'm going to make is that, instead of displaying the name of each employee, I'm going to display the length of their name. And if I run this application by pressing F5, we get 5 and 6, which is the values that we expected. But let's see what happens if I common out this line of code that's initializing the name field for e2. Now I'm going to run the application again by pressing F5. And we're going to get a runtime error. We're going to get an exception that tells me that I did something wrong, and then it brings the application to a halt. And say null reference exception which generally happens when you try to do something with the variable that is not pointing to a valid object, it's null. Perhaps it hasn't been initialized. And that's exactly what happened here. If we look in the Autos window that debugger gives us, we can see that e2.Name has a null value. It's not pointing to an actual string. Thus, when we try to get the length of something that doesn't exist, the CLR gives often first an exception and says, you've done something that's illegal, something must be wrong in your program. The question is why is name null? Well, it's never initialized. The employee class doesn't have a constructor or it does that actually has an implicit default constructor. But what that implicit default constructor does is just initialize everything in the object to the default values. And the default value for a string and other reference types is going to be a null value. The default value for an integer, doubles and floats, and things like that will be a zero value. But for strings that's null, and that prevents us from getting a link amount. So a null value might surprise someone who's using my class, they might think that we initialize everything to some sensible value. So the way we could fix this is to actually provide a constructor for employee. And I'm going to type C-T-O-R which is a-- which will activate a code snippet in Visual Studio. And then if I hit tab and tab again, it's like a macro that will automatically expand into a constructor code for me. So you don't have to type public employee parenthesis and opening brace, and so forth. Inside of here, I'm going to initialize name to an empty string. So essentially what we have before or as an implicit default constructor that just did this, set name to null. I'm going to change it, so that name is an empty string and press F5 to run the application again. And you see that we get 5 and 0, the length of an empty string is 0. And just so you know, there's another way I could've achieved this. And that is that when you have a field in a class, you can provide an initializer for it. So this is essentially doing the same thing. When this object is constructed, any code that you have in this on the right hand side here is going to execute, so this is essentially going to assign an empty string to name, and that code will also work. Now what we've written here is known as default constructor and it's a default constructor because it doesn't take any arguments. I can use it with a new operator and not pass any parameter zone. However, let's comment this out and let's write another constructor. But this one, we're going to ask the user to pass in a name when they're constructing an employee. And what we'll do is we'll take this name parameter that gets passed in, we'll just assign it into the field. As soon as you provide a constructor that is not a default constructor, and take some parameter, you no longer have this implicit default constructor as part of the class. So code that is invoking new employee, I'm not passing in a method, passing in a parameter, that's not going to work anymore, this becomes a compiler error. And I am forced to pass something in as a parameter. That would fix one error, but we still have a problem here. It is possible though to have multiple versions, multiple constructors, so here's a default constructor that doesn't take any parameters, here's a constructor that takes a name parameter. And that will work, that will let things work again. And let's just run the application. And we get a 5 and a 4 which is correct for the way we have things set up now. This is an example of overloading in C Sharp, you can overload methods, and when you're overloading what you're doing is you're providing multiple implementations of a method. They all have the same name but they take different parameter types or different number of parameters. In other words, it is an error if I tried to write a second constructor that took a string parameter. Even if was using it to initialize a different field, this will make the C# compiler unhappy. And that should make sense because when you're reading this line of code here, new employee pass in a Paul. Well, which constructor should it be invoking, first one or the second one? It would be completely illegal though to have a different parameter type here like int because then the C Sharp compiler can differentiate between these two constructors. This is going to call the one that takes a string. And this is true anytime you write methods, you can overload them in this way. But we're not using this constructor so let's get rid of it. And I'm also going to remove this initializer because we want to provide a default constructor, and inside of here, we can just make sure that name is always initialized to at least an empty string. That way, anyone who's using our class should never see a null value for this name field unless they explicitly assign it themselves.
Reference Types
In that last demonstration, I used the term reference type. You might be wondering what a reference type is. In a later module, we'll be talking in more detail about reference types but I wanted to give you enough information to understand a few basic concepts that you need to know. Anytime you create a class definition, you're creating a definition for a reference type. When someone instantiates an object based on that class definition, the object itself is going to be stored on the heap, that's a large pool of memory often measured in gigabytes that's available for storing objects, you can think of it like that, that big pile of dough that we're going to take the cookie cutter to. The way that you interact with that object is to have a variable that references the object, that literally points to that object in memory. We might have instantiated three different employee objects but our variable is only going to reference one. In the demo application that we've been writing, employee is a reference type, it is based on a class. And e1 is referencing an employee object on the heap, but it's not forever bound to this employee object that it created here. So for instance I could go out and point it to another employee object that we created. And then say the name of that employee is Linda. If we run this and you could see where, in the output e1.Name, and we get Linda on the screen. Something else that's interesting about reference type is that you can have multiple variables reference the same object. So I could create a variable e2. I'm not going to initialize e2 to a new employee object by constructing another employee object. Instead what I'm going to do is have e2 reference the same object that we created and assigned into e1. And then I will change the name of that employee to Linda. And you can see here, we're still uploading e1.Name, but when I run this, we'll see that the name is indeed Linda, and not Scott. And the reason that works is because we have two variables that are both referencing the same object on the heap. So any change that I'd make in e2 will be seen through e1 and vice versa.
Object Oriented Programming
At this point, we've learned enough to start talking about the Object Oriented Programming features of the C Sharp Language. When we talk about Object Oriented Programming, there's three primary concepts that you want to become familiar with. The first concept is inheritance or the ability to define a class that inherits state and behavior from other classes. This is one approach that you can use to reuse code in a C Sharp Application. Another OOP concept is encapsulation, that's the ability to hide some of the details of the inter-workings of a class. When you write a class, you want to expose just what other people need to get their work done and you want to shield them from some of the low level details that aren't important to them, that reduces that complexity of your software. And the third concept is polymorphism. This plays a role with inheritance and that you can reuse code to inheritance but you have an extensibility mechanism whereby you can customize a class that's inheriting behavior from another class and tailor to a specific need. We'll be taking a look at all three of these concepts in the rest of this module.
Inheritance
The first concept that we'll look at in detail is inheritance. Inheritance is the ability to create a class that extends and reuses code and data inside of another class. Every class that you create is going to at least inherit from system dot object by default. System dot object is what we call the base class for every type of object that's going to be alive inside of a .NET Program. That will happen if you don't explicitly specify a class you want to inherit from. We can also inherit from other classes that are in the .NET framework or classes that you write. And when you establish an inheritance relationship, what you're doing is the class that you're inheriting from, you're going to gain all of the state and behavior that's defined in that base class. So for example, in this code snippet, we're defining an Animal class. By default the Animal class is going to inherit from system dot object because we haven't specified another base class for it. And this Animal class is going to have a public property called Name. We'll have the ability to set the name to different values, we'll have the ability to get that name. Once the Animal class is defined, we can define another class called Dog, but instead of inheriting from system dot object, which is the default, we're going to tell the C Sharp compiler that we want to inherit from an Animal base class. And what that means is anytime we instantiate an object of type Dog, that object will have a Name property, we've inherited that from the base class. And we can create multiple derived classes from this base class. So I can create another class called Cat and tell the C Sharp compiler that should inherit from Animal, and then Cat objects, and Dog objects will both share this Name property. This is a simple diagram showing the inheritance relationship we have. Animal serves as a base class, Cat, and Dog are what we call derived classes. Sometimes you also hear the term subclass, Cat a subclassing Animal.
Demo with Circles and Squares
Many of the technologies inside of the .NET Framework make extensive use of inheritance. For example, here in the WPF Application, we have a main Window class that it inherits from a base Window class that's written as part of WPF. System dot windows dot window, you can see in the description here provides the ability to create, configure show and manage the lifetime of Windows and dialogue boxes. We inherit all of those capabilities into our Main Window class. That's why we can put something onto the screen without writing a lot of code, all of that behavior is already built in to our class, even though we don't directly see it here. But we can take advantage of things that are built in, for instance that base class defines a Title property that if we set it, it will show up in the Title bar of our window and really to do that, we just set the property, we didn't have to do any other things that we might have to do in Windows programming to get that done, it's a simple property set. Let's look at something else, here are employee, if I type e1. you can see in the IntelliSense Window, we have these method Equals, GetHashCode, GetType, and ToString. Where did they come from? They didn't come from our class definition, we just had a couple constructors and a Name field. But remember, every class that you're writing on the .NET Framework implicitly derives from system dot object. So even if you don't specify that, it's implicit and it happens. Those members like-- what we're seeing such as ToString and GetHashCode. Those are methods that are defined by system dot object, we inherit those, and you'll see those available on every object that you write in .NET. Let's change directions just a little bit and instead of putting text on the screen, let's actually put some colorful shapes on the screen like squares and circles. If I want to draw a square, what I might start off with is a class that encapsulates the drawing of a square, that's going to have a draw method. And I need something to draw on, when I'm inside of the draw method. In Windows presentation foundation, one way to do that is to use a Canvas. Now, since we're going to require a Canvas to draw on, I'm going to make it a an argument to a constructor and force someone who's creating my square object to pass me in a Canvas that I can draw on. And since I actually need a reference to this inside of the draw method and not just in the constructor, I'm going to create a field called Canvas, and save a reference to this Canvas inside of the constructor. So I can use it inside of the draw method. But before we do that, how we're actually going to paint the lines and fill the square with colors. WPF can help us out there too because it has a built-in rectangle class. And what I'll do inside of the constructor is instantiate that field to a new rectangle and set some properties that it has a width 10 pixels and a height of 10 pixels, that it fills itself of the green color and have a black outline. Now I have completed the draw implementation for square and you can see what I'm doing is, I'm going out and calculating a left in a top position where I'm going to place the square on the Canvas. And I'm doing that using a random number generator that's available in the .NET Framework, the random class. Essentially, invoking the next double functional return a number between zero and one, and I'm going to use that as a percentage to multiply by the actual width and actual height, to make sure it gets positioned somewhere on the Canvas, the top left to the rectangle should be on the Canvas somewhere. I'm going to set the values that appears on that place. And then to actually place on the screen, I go up to the Canvas and tell it to add this rectangle as a child object. So it's something that Canvas is now responsible for, it's going to put on the screen. I've also implemented a circle class. And a circle class takes a Canvas in the constructor, it has a draw method. And if you look at these two classes, there's a lot of similarities. The draw method in fact is exactly the same except for the fact that one is working with an ellipse and the other one is working with a rectangle. Generally speaking, this is how I approach inheritance. If I have two classes that start getting a lot of duplicated code, I start looking to see if there should be an inheritance hierarchy somehow so we can share that code between the two classes. So instead of having a full implementation of draw inside of circle and inside of square, let's create a base shape class that both square and circle can inherit from. Now I finished the implementation of the shape class, and you'll notice that it still has constructor that requires a Canvas because this is where we're going to do the drawing. And it still has the draw method that uses that Canvas. All of that code that was duplicated in both that circle and the square class is now inside of shape. And our circle and our square now inherit from shape, these become very simple classes, they don't need to know about the details of drawing that behaviors inherited, it's taken cared of for us. All we need to do is focus on creating the type of square that we want. So we're still creating a Rectangle and initializing it with specific colors and a width and a height. Back up here in the draw method, there is one subtle difference instead of working specifically with the WPF ellipse or a WPF rectangle, it's working with a UI element. This is one of the neat things that you can do with inheritance. I have a field here, typed as UI element. And because rectangle and ellipse in WPF both ultimately inherit from UI element, I can treat them both as UI elements. So I don't need to worry if I'm specifically dealing with a rectangle or dealing with ellipse, they're both UI elements. I'll give you another example of this in just a minute. Something else I want to point out is that, there's a compiler error currently in my circle class, and the reason is this. When you're constructing a new circle, what the C Sharp compiler does, is set up the code to invoke the constructor of circle as well as one of the constructors of the shape class. Because remember, when we're constructing a Circle, we're really constructing shape too. We're inheriting all that stuff, that has to be initialized, that has to be a constructor invoked on the shape class too. Now what the C Sharp compiler is telling us, is that, when I'm constructing a circle, I don't know how to construct the shape. There's no constructor, there's no default constructor that takes zero arguments, you have to tell me what constructor to invoke, and give me some arguments. Because this requires a Canvas, and there's a special syntax for that in C Sharp, what you do is after the constructor method, you use to base keyword. And then pass in any arguments that are required by your base class constructors. The sequence of events then when you say new circle is that the C Sharp compiler will invoke the base class constructor first. And then, we'll do that by passing in this Canvas and so any initialization that needs to occur inside of the base class will occur. And then, it will invoke the constructor that you've chosen for the derived class, in this case circle. And this code will execute-- and at the end you'll have a fully initialized object that is a circle. And it has everything that it needs inherited from shape also. With the squares and circles in place, let's jump back into the loaded event for the Main Window and actually put something on the screen. We can construct a square and assign that to a variable of type square. We can construct a circle, and assign that to a variable type circle. We can also construct the circle and assign that to a variable of type shape. I'll show you where that's performed just a second. But remember it's the shape class that defines the draw method, that means anything that is a shape will have a draw method, therefore, we can walk up to s3 and invoke a draw method. Let me press F5 to run this real quick and we should see three shapes appear on the screen, one square and two circles, that's perfect. Let me show you a couple of things that you cannot do. I can treat a circle like a shape then I can treat a square like a shape. But obviously, I cannot treat a square like a circle. Those two types are not related, so the C Sharp compiler will be unhappy there. But I can of course, treat the square like a shape. Something else I wouldn't be able to do is let's say that I had a custom method defined on my circle class. So let me add something here called compute circumference. So it doesn't actually do any real computation as yet. But what we'll see is back here in the Main Window, s2 is type circle. So because that variable is type circle, the C Sharp compiler will allow us to invoke compute circumference. Now s3 is a circle, that's what we created there. But we type that variable as a shape. So the C Sharp compiler doesn't know-- isn't going to treat that variable reference like it's pointing to a circle, it's going to treat it like a point to a shape. And the only method that we can have there is the draw method. We can not invoke compute circumference. Now that might seem like a drawback, there are many times when you want to treat objects do a base class reference. I showed you one, when we constructed the base shape class here and that we wanted to treat WPF rectangles and WPF ellipses as UI elements. Because that allowed us to write generic code inside this draw method, that could draw either. Another example would be, let's say that we wanted to put a hundred shapes on the screen. What I could do is I could set a loop. So this is looping for I equals zero to I is less than 100. And then incrementing I each time the loop, this is going to run a 100 times and each time to the loop, we'll draw two shapes, we'll draw a square and a circle. But both times, I'm going to invoke the same method to actually get it on the screen, a method called DrawShape. And inside of DrawShape, we can draw any kind of shape, we can draw anything that inherits from that shape base class. Because we know it has a draw method. So when I run this again, the-- what I have is some very generic code that knows how to work with shapes and get things on to the screen form me.
Access Modifiers
Access Modifiers are keywords in the C# Language that allow you to achieve encapsulation. Using these keywords, you declare the accessibility of a type or member. And that allows you to selectively expose functionality for clients to use or selectively hide implementation details that you don't want to burden other people with. For example, the public keyword, you can apply it to a class or to a member of a class like a property or method. And it grants open access to whatever is declared public. I can write code inside of the same project, where I can write code outside of the project and have access to anything that you declared as public. Protected is a little bit different and that you can only apply it to a member. And when you declare a protected member, access is limited to the class that's declaring that protected member and any derived class. We have an example of that in a sample project. We have our Shape class that declared a protected UI element underscore element. And that means, we're able to use underscore element inside of method that are inside of shape. And we're also able to access underscore element and derive classes like circle and squares so they can set that element. But what we cannot do is access underscore element from outside of the class. So I cannot get to shape number 3 underscore element. It's not accessible. Internal is a keyword that you can apply to a class or to a member of a class. And the limits access to the current assembly. This is the default accessibility of a class in C Sharp. So when I declared the circle class here, it's an internal class, I can only use it inside of this application. If someone else references the assembly that we produce when we do a build, they won't be able to legally access circle. If I wanted to expose this, I could make it public. And once I've done that, circle would be available outside of this assembly. There is also protected internal. This only applies to a member, and it limits access to that number to the current assembly and to derived types. And finally, there's private. This is the default accessibility level of a member and it limits to access to just inside of the class. An example here would be in our shape class, we have a field called Canvas. We didn't explicitly specify the accessibility here, so it is going to be private. So adding the private keyword there doesn't change anything. And when I'm inside of circle, unlike the element that I am allowed to access, I cannot get to that Canvas, now an implementation detail of that base shape class, it's hidden from me, even when I'm in a derived class.
Abstract Classes
Another keyword you come across in C# development is the abstract keyword. This keyword can apply to a class and also to members of a class, so to methods and properties, as well as indexers and events which we'll be taking about later in this course. The important distinction is that an abstract class cannot be instantiated, someone cannot use the new operator to create an instance of an abstract type. This means abstract classes are almost always designed to be used as a base class. It's a place where I want to put some code that I'm going to reuse to inheritance, but I don't want people to be able to instantiate that base class that I've designed. And if that abstract class has any abstract members like an abstract method. You must implement those abstract members in a derived class to make what we call a concrete class. A concrete class is one that can be instantiated, you can use the new operator with it. Here's an example, abstract class Animal, it has an abstract method called PerformTrick. The interesting thing about abstract methods is that you don't have to define a method body for an abstract method. It doesn't an implementation. This is simply a placeholder, so that if people have a reference, a variable that it's type is Animal, the PerformTrick method will be available to them, even thought the implementation isn't there. The implementation is going to be provided through some derived class like Dog. It overrides that abstract method to provide an implementation. We'll see a couple different uses of the override keyword. One is to provide an implementation of an abstract method. I can show you one example, where you would want to use an abstract class. And that would be in our sample project, this shape class, where'd we really want someone inside of the code here to create a new shape and try to draw it on the screen. Conceptually, it doesn't make sense, what is the shape that's not a rectangle or it's not a circle. We didn't instantiate a concrete type, we instantiated, tried to instantiate this abstract thing called shape that really doesn't have a form. If I want to prevent that, if I didn't design shape to be used in such a manner, I can make shape an abstract class. And now when I do a build, I'll get a compiler error, cannot create an instance to the abstract class or interface shape.
Virtual Members
The virtual keyword in C# allows you to achieve polymorphism. Once you've applied the virtual keyword to a member that becomes what we call a virtual member. And then you can override that member in a derived class. Essentially, change the behavior become polymorphic. Members are non-virtual by default. So you have to selectively apply the virtual keyword in areas where you want derived classes to be able to change the behavior of what you've provided. For instance, in this Animal class, there is a virtual method called PerformTrick. And inside of here could be some code that is an implementation of something that all Animals can do. Then when someone else creates a Dog class, they inherit that behavior from Animal. But they're going to override what happens to PerfomTrick. And perform their own sort of dog trick. Now inside of here, you also have the option of calling into the base class implementation and invoking that behavior too. Sometimes that, is something that you need to do with some frameworks. The important concept to understand here is that virtual members are dispatched base on the runtime type, not the type of the variable. Let me give you an example while using our sample project. Let's say that when a circle draws itself, I'm going to change the behavior just ever so subtly. And I want to turn it-- the circle red. So what I'm going to do is I'm going to say, element dot fill equals a new solid color brush that is going to be using the color Red. That will change the color of the element. Now we actually have to do the drawing still. So I'm going to call into the base class and still take advantage of the code that's inside of there. So with this code in place, let's flip back into our Main Window. And remember that we're creating a square and a circle, and a circle, and a hundred more shapes. And run this program and see how much red appears on the screen. Well, this is sort of interesting. I only see one red dot out of-- about a hundred. Now, why would that be? Well, remember that I said that virtual members are dispatched base on the type of the object. And that means that regular methods are dispatched based on the type of the variable. So down here, we're creating 100 Circles and we're passing them to a draw shape method that is invoking the draw method, but it's invoking that draw method on a variable that is typed as shape. And that means that this line of code is always going to invoke the draw method that is in that base shape class. The only place where we are actually invoking draw and setting the color to be red is when we are invoking draw on a variable that is typed as circle. So s2, when we do s2.Draw that's going to invoke the draw that uses a red brush and tells the base to put it on the screen. If we went through polymorphism, first, let's go down here to the base class and mark draw as a virtual. I'm going to do a build and you'll notice that we get a warning here. What I haven't done on this-- in this derived class is I haven't told the C Sharp compiler that this draw implementation should override what's in the base class. Instead, what I've effectively done is create a second implementation in the draw method. And if we run this program again, what we're going to see is the same behavior, there's only one red dot. And the reason is that, in C Sharp terms, this draw method is hiding that base class draw method that is virtual and this is still not a virtual method. If I don't want to hide that method, if I really want to change the behavior of what's going to happen to circles, I'm going to use the override keyword. And now what happens is anytime that the draw is invoked on a shape that is of type circle, regardless of how we've typed the variable, at runtime, the CLR is going to look and see that the implementation of draw is being overridden in this derived class and this derived circle class. And so it's always going to invoke this method. So let's run the program one more time and now we see lots of red circles. So just to recap, before we introduce the virtual keyword and use the override keyword, shape dot draw was always going to do the same thing. It's always going to invoke the draw method on that base shape class. But now that this is virtual and we override it in a derived class, we're effectively changing the behavior of what happens during that draw.
Static Classes
The static keyword in C# is important because when you use the static keyword on a member like a property or a method, the member then belongs to the type and not to an instance of the type. Let me give you an example. Here's an instance property called circumference, but what I want to call your attention to is Math dot PI. Math is a class, PI is a static property on the Math class. In order to reach that property, I don't need to instantiate the Match class, I don't need an object. In fact, it's an error to try to invoke a static member through an object instance. Instead, you need to use the type name. You can also use the static keyword in front of a class to create a static class. And a static class can have only static members, you can't have any instance members, and you cannot instantiate a static class. Many times, we create static classes with static members just to handle scenarios like this, where you need a quick and easy way to reference something that will give you the value of PI and you don't necessarily need to instantiate an object just to do that. Inside of our sample project, I was using a static member on the shape class. It was the random number generator, so underscore rand is a static member. And it's also implicitly private because I didn't put any accessibility modifier here. We could make this public but even when it's public, I would not be able to get to that through an instance of the class. So I would have to walk out to the shape class and get to that random number generator. Of course, we don't want this to be a public number and I also wanted to point out that from within this class, it's legal to access that static member. And I can do that without using the type name. There's another example in here, every time we're setting up a brush to paint the background of a shape or paint the outline of a shape, we're using colors dot black. The built-in colors like green, black, and red are all static fields on the colors class, so we don't need to instantiate an object of type colors, we can just use the type name dot and then the static member. One implication of the static keyword that you should be aware of is that, unlike instance fields for every object that is instantiated whether it's a circle or a square is going to have its own copy of a Canvas field, and its own copy of an element field because those are instance fields. A static field, there is only ever one copy. No matter how many circles you create or how many shapes you create, there's only one copy of this rand field for the entire application.
Sealed Classes
C# has the concept of a sealed class and this is done by applying the sealed keyword in front of the class. A sealed class cannot be inherited. There are some scenarios where you want to prevent extensibility, you don't want someone to misuse a class that wasn't designed for extensibility or inheritance, and so you seal it. You'll often run across sealed classes in the .NET framework. May times Microsoft will seal a class for performance reasons or because there might be security implications. One example of a sealed class is the string class, system dot string, Microsoft sealed this class. It's a bit of a magical type and because we used so many strings inside of software, it's heavily optimized. We're prevented from extending string because it's a sealed class. So if we tried to write a class that set it in inherited from String, that would be a compiler error.
Partial Classes
And finally, I did want to tell you a little bit about partial classes because you will see the partial keyword quite frequently. That's usually when there is a designer involved. Like the designer that we're using in a WPF Application. The key to understanding a partial class is that it's simply a way that you can split a class definition across multiple files. So in 1 dot CS file I can declare a class Animal and define a few methods and a few properties. And then a different CS file that it's inside of the same project, I can have another definition for Animal that includes a different set of properties and methods. When the compiler comes along, it's going to merge those two different sets of properties and methods and static fields, and whatever we have defined into a single class definition. Also in C Sharp, we have partial method definitions. Partials methods are really extensibility points and here's our example. Here we have a partial class called Animal. And in here, every Animal is going to have a name property. And we have a partial method defined OnNameChanged. Just like an abstract method, there's no implementation of this method provided here but somewhere in a different file, we could provide an implementation of OnNameChanged. If this implementation is not here, or OnNameChanged will be optimized away if it never existed by the C Sharp compiler. If you're using one of the database technologies like link to SQL or the entity framework, this is where you'll see partial methods come into play.
Summary
In this module we saw that C# gives us all the features that we need to construct software in an object-oriented fashion. We can achieve encapsulation by being careful for what we mark public. We can certainly have private state, private methods, private properties, that are hidden. We saw that we can use inheritance and also polymorphism. We can use that to reuse code, but also specialize or tailor classes to fit a specific scenario. And then, we took a look at a couple additional features, keywords that the C# language provides, sometimes for performance like the sealed keyword, sometimes for convenience creating static members and sometimes for extensibility or just the role that partial classes play.
C# - Types
Overview
Hi this is Scott Allen of Pluralsight and in this module I want to teach you about types and assemblies in C#. In the last module we talked about reference types just a bit. But in this module I want to draw more into the two categories of sites in .NET, value types and reference types and come to a good understanding of the differences between those two. We'll also look at how to define value types using something called an enum and a struct. We'll talk about interfaces which is another way to describe a type in .NET and look at a collection of objects using an array. And then we'll see how all those gets packaged up into assemblies and we'll talk about the importance of assembly references.
Reference Types
Let's have a quick review on reference types. I know I am dealing with a reference type when I have a variable that's typed as some class definition that I have implemented. Any time I write a class I'm creating a reference type. When I have a variable that's typed as reference type I know it stores a reference to an object that's literally the value inside my variable is a memory address and that memory address points to an object that's sitting out there in memory. Multiple variables can point to the same object. So if I new up an employee by invoking your constructor and giving an employee object back. I could assign that to variable of type employee named E1 that's going to point to that employee object. I could also assign that same reference value to E2 so E2 will point to same employee. If I do E1.name or E2.name both of those should return the same name, they're both pointing to same employee object. I can also have a single variable point to multiple different objects of that same type over the lifetime of the variable. In other words I could say E1 equals new employee and it would no longer be pointing to this employee object. It would be pointing to another employee object in memory. We've also talked about objects being allocated on heap when I'm using the new operator with a reference type these objects get a place in memory reserved for them. It's an area called the heap and it's globally available to anything in your application. The .NET runtime manages this heap and it cleans objects that were no longer using. But once we've put an object onto the heap it would be available for the duration of our application also as long as we have a variable that referencing it.
Value Types
Every type in .NET falls into one of two categories. It is either a reference type or it is a value type. A variable that is a value type holds the value now. It doesn't contain a memory address. It's not a pointer. It doesn't reference something else in memory. For example if I have a variable called Y and it's a type int or int32 and it's a local variable so it's inside the curly braces inside of a method definition. And I assign it the value 4. That value 4 is literally stored in the location for variable Y. This is no longer a pointer to something that's out here on the heap. The value is contained wholly inside of that variable. Because of this value types are relatively less expensive than reference types I don't need to find a free area of memory, block it off, copy some value inside of there and hold a pointer to that thing, I just have the value inside this variable. One characteristic of value types is that they should be immutable and the value types that are built in to the .NET Framework are all immutable. This means you can't change the value of a value. This doesn't mean that I cannot write the value 4 into the variable Y and later change my mind and assign it in the value 2. It just means that those values 2 and 4 are immutable. A 2 is always a 2. A 4 is always 4. I can't change the value 4 suddenly be represented by a 6 or a 7. The idea here is that a value type is typically a primitive type. It's something that you use quite frequently. It's typically short-lived and it's usually and should always be small. Value types, the general of thumb is to keep them less than 16 bytes. Many of the built in primitives in .NET are value types. For example int32, int64, DateTime and Double, those are value types. And int32 uses 32 bits that's 4 bytes and that's smaller than the 16 byte rule of thumb. And one of the reasons that that guidelines is in place is because every time you pass a value type or assign a value type for instance if I say Y equals X, assign the value X into Y, this is a copy operation. It's taking whatever is an X like the value of 8 and copying that into the variable Y. In this case it's moving 32 bits which isn't very expensive. As value types become large those copy operations become more expensive. I'll be doing a demonstration in just a bit to help drive these points home but before we can do that demonstration we have to know how we can create or define a value type.
The struct
One way to create a value type with C# is to create a structure using the struct keyword. A struct definition looks very much like a class definition. You can make it public or internal. You can give it any name you like. You put the definition inside of curly braces. But there are a couple of rules for a struct. First of all you cannot inherit from a structure. Once you build one it's implicitly sealed. You also cannot select a base class. All structs inherit from System.ValueType implicitly which in turn inherits from System.Object. But like a class you can have fields and properties and methods to a struct definition. Remember the rule of thumb is that a struct should be small so ideally less than 16 bytes. The data type that you are modelling should be a primitive type. Here we have a complex number that has real and imaginary components. We can also consider modeling a color as a value type or perhaps a point with X and Y coordinates. These are small things that are typically short-lived. Perhaps you need to create many of them for instance you might need to work with a thousand points as you're doing some matrix operations and storing lots of temporary result and you don't want the overhead of creating an object on the heap each time. That would be an ideal scenario to create a value type.
Testing Reference Types
To demonstrate the behavior of reference types and value types I'm going to come in to Visual Studio and create a new project. But this time I'm going to create a new Test Project. Generally you create test projects so that you can write tests against production code. But I think Test Projects are also a great way to explore language features or an API or a library that you might not understand because you can write test and verify the way things are documented or verify what you believe should happen. So I'm going to name this project cstypes and Visual Studio will go out and create a Test Project for us. It's going to include a class called unit test 1. And just to keep things simple I'm going to delete all of the code that's inside of here so we can pretty much start from an empty slate. Inside of a unit testing project you organized tests inside of classes. You create regular C# classes only you'd decorate them with something that we call an attribute. This describes this class as something that's going to contain tests. We'll talk more about attributes in the later module. And it's quite common for people to give very descriptive names to their test classes and to their test methods so we could call those ReferenceTypesAndValueTypes 'cause we're going to be exploring those features. Now I want to actually write a test and I do that by adding an attribute that tells Visual Studio I'm about to create a TestMethod and then I rate a method. So this is going to be a test. We're not going to give it a name yet. I'm just going to show you how this works. Inside of here I could write and assert. So I want to assert that something happens. I got some result or something didn't happen. And here I'm just going to say assert the true equals false. Now we know that that's going to return a false. But I'm going to right click on this area of the code and select run test from the context menu and Visual Studio will automatically go out, load up this class and execute methods that are test methods. And you can see that this test failed, the Assert.IsTrue failed because that was false. Let me put a true in here. Run the test again and you'll see the test pass. We can use this type of behavior to validate some exceptions that we might have about a framework. Now on the demo project I have written a simple class called invoice. I've just included this class in the same file as my test just to keep things simple. This invoice class has 3 public properties that you can both read and write and that is ID, a description, and an amount. That the state that we want to track for an invoice. Inside of the task I want to do some identity test. In .NET two objects have the same identity if they share the same memory location that is they're the same object. With that in mind let's create two instances of the invoice class. First invoice and second invoice, we're going to set the ID description and amount values all to the same across both instances here. I'll point out that the M suffix here is the way to tell the C# Compiler that 0.0 this is a decimal value as supposed to a 0.0 that would just be a double value. And the proper way to test identity in .NET is to use a static method on System.Object called reference equals. And to that object you pass the two objects that you want to test. Now we know that invoice is a class therefore first invoice and second invoice are reference types. And when we say new invoice we're establishing an object that gets allocated on the heap and they should be two different objects, first invoice and second invoice. Thus this task reference equals should return false. They should not have the same identity. So let's test this by running it. ( Pause ) And our test passed. Now since these are two different objects then I should be able to do this. I should be able to assert that the first invoice ID is equal to 1. I can change the ID of the second invoice to a 2 and then we could assert that the second invoice, its ID property was set to 2. And we can assert that the first invoice wasn't changed so its ID property is still equal to 1. Let's run our test again, it should still pass and it does. So now let's try something else. Let's say that the second invoice equals the first invoice. What I'm doing is copying the value of first invoice and remember the value is a pointer into second invoice. So what do you think will be the result of object.reference equals now. Let's test and see if that's true because I think it will be. And in fact let's go one step further. Let's go to the second invoice and set the ID equal to 5. And then what do you think this will do my assert is true, firstInvoice.ID is equal to 5. Should that pass or fail? Let's run the test and find out. And our test still passed. The reason the test pass of course is because after we did this assignment both second invoice and first invoice were referencing the same object, and when we set the secondInvoice.ID equal to 5. We were putting 5 in that object that both first invoice and second invoice were referencing thus we see that change when we test against the first invoice ID property.
Testing Value Types
Let's see if what we have learned about reference types will apply to value types. With reference types we had two variables. We asserted that they were both pointing to the same object. And when we made a change through the second variable we could assert that we saw that same change happen in the first variable. So we're updating the same object and let's try that with integers. We can create one called X and give it the value 5. We'll create one called Y then we'll set y to 10, and will this be true? Will X be equal to 10 because we set 10, Y equals 10? This test assumes that integers work like reference types in the sense that we created something that X points to and we put 5 in there then we pointed Y at the same place and we placed the 10 in there. So if we ask for the value of X we should see a 10. But if we run this test we will find that it fails. So our ValueTypeTest failed. And this is because as we have discussed in the slides value types behave differently. Here we create a variable called X and that is value type so it stores the value. We actually have a 5 placed into the memory location for X and we have a second variable called Y. At first we give it the same value 5 is copied into this location but just after that we overwrite it with a 10 value. So you can see that X is not equal 10. X still holds its own value to 5. Thus if we wanted have this test passed we should assert that X is still equal to 5 while Y is now equal to 10 and we run that test and it now passes. If you have been following along you might say, "Wait second Scott. Here we're dealing with integers and you're saying they behave 1 way as value types, but up here we were dealing with integers too. We are setting invoice.ID and ID is a property of type integer. Why are these behaving differently? You're telling ones part of a reference type and the other on is a value type. I don't quite understand." Let's look at a diagram and see if we can clear up the confusion. Here we are inside of a method definition, so we have the curly braces, and we have what we call local variables and local variables are the-- the space for those local variables will be allocated on the stack. That's the temporary storage location that gets allocated for variables that are inside of a method, local variables. And we have a variable in there, firstInvoice, that's a type invoice. We know that's a reference type and we know it's actually stored here as a point of value and that point of value can point to an object that lives out on the heap. Same thing with secondInvoice, it's a type invoice. It's also a reference type. We can point it to the exact same object. Now part of this object that we declared was an integer property called ID. The value for that is also stored on the heap because ID is a part of the invoice class. Same with the amount property that's of type decimal-- decimal is value type that's actually stored in the memory that's allocated for the object. Description is a little bit different. It's a string type and we'll be talking more about strings in a later module but strings are reference types. That means what-- what is actually stored in the memory for this object is not the value of the string or the description which was test but again a pointer. So what we have for description is a pointer to another area, the heap that will actually contain the value for our object. And this is completely different than integers which were local variables that just space reserve for them on the stacks. So an X can hold 5 and Y can hold 10. Essentially to summarize here, value types hold the value like 5, 10, 1, 2.3. Reference types always hold pointers. So the firstInvoice point somewhere, secondInvoice point somewhere, the description which is a string point somewhere.
Passing Parameters
Understanding the difference between how reference types and value types behave becomes important when you're passing parameters to a method. In C# parameters always PassByValue by default. This means that for reference types you're passing a copy of the reference. Remember that the value of a reference type that is the information that is actually stored in the location reserved for that variable is a pointer. It's reference that's pointing somewhere and what you're passing to method when you invoke a method and pass a reference type as parameter, so you're passing a copy of the value, the value as a pointer. For value types the value is stored in the variable so you're just getting a copy of the value again. For an integer that would mean you might copy 5 or 3 or 42. The most important point to understand here is that changes to the value itself inside of the method you are invoking don't propagate back out to the caller. In other words if I have a reference to an object and I pass that as a parameter to a method and that method makes changes to the object, I'll see those changes to the object because I'm pointing to that object. The method has a parameter that's pointing to that object and any changes that makes to that object I'll be able to see those when control returns to my method. But it changes the value that is inside of the method, that variable it points it to a different object, it doesn't mean that my variable back in my method points to a different object. I'll demonstrate this inside of a test in just a bit. That will make things more concrete. When you are implementing a method you can change the default of pass a parameter by value to actually get a parameter and have something passed by reference. This is done by using a ref or an alt keyword to pass a variable by reference. For instance in this method work we're asking for a text parameter of type string and we're saying we want it passed by reference. In other words we're going to get a reference to a reference so we'll have a pointer to a reference. And now we can change where that parameter is pointing to and ultimately the caller is going to see that affect where their variable is pointing to. Here's an instance of asking for an int parameter by reference using the alt keyword. We can now change the integer value that the caller has because we have a reference to that integer. The key distinction between ref and alt, they both mean pass by reference. But what ref tells the C# compiler is that you are going to use this variable inside of the method. Therefore it should be initialized by the caller before they pass the parameter. The text parameter that we get here we are going to use it and pass it along to a TryParse method on int32. The C# compiler will force the caller to initialize text before it invokes this method. That's different than the alt keyword because that tells the C# compiler, it doesn't. We're not going to use this incoming value we're simply going to compute something and place it in there and allow that to propagate back to the caller because it is a pass by reference.
Parameter Demo
Let's go into our demo project and look at a test called PassByValue. Inside of this method we'll construct a new invoice and set it to ID equal to 1. We'll also create an integer variable and set its initial value to 1. Then we invoke a method called DoWork. DoWork takes two parameters, invoice and int. Its using the default convention of passing by value. And inside of the method we'll change the invoice parameter the ID property that invoice to a 5 and we'll change the value to a 3. The question is then, "What do I need to write in this assert statement for the text to pass? What will be the value of the ID property of this invoice object? Will it be the one that we initially assigned here or will it be the 5?" I'm going to go with the 5. The next question then is, "What do we need for this assert to pass? What will be in this integer value? Will it be the 1? Or will it be the 3." I'm going to go with the 1. Let's run the test and we'll see that PassByValue passed. So the-- both of those asserts work. And the reason is because we have an invoice object out here on the heap and this invoice variable was pointing to there, we passed a copy of that reference in this invoice variable so it's pointing to the same object. When we wrote the 5 into the ID property that was written into the object, so we see that both from inside of DoWork and here in the caller after DoWork is completed. For our value type, however, we know that-- we know something here is stored on the stack that had the value 1 inside. We passed a copy of that into this parameter. So initially this value had a 1 inside of it and there's space reserved for that on the stack 2. But later inside of DoWork we overwrote that memory location with 3. However, because this is a value type that had no impact on the variable that's back here in the caller thus value is still equal to 1. Now let's change the implementation of DoWork ever so slightly. Instead of this line of code that is just setting the ID property of this invoice parameter we get in. Let's actually take that invoice parameter and point it to a new invoice object and set the ID of that object to 5. Let's run the test again and we'll see that our PassByValue test failed. So the question you should be asking is, "Why do we no longer see the 5 here?" Well what happened is we constructed an invoice object here, came out on the heap, and we put 1 in there for the ID property. We passed a copy of that reference into this variable so initially this was pointed here and initially this one-- this parameter is also pointed to this object. But what we did here is we say invoice equals new invoice that constructs another invoice object on the heap. We set its ID property to 5. This variable is pointing to that new invoice. But the original value we had here and PassByValue it's not impacted by this change at all. We don't have the ability to change the value of this variable, this invoice variable anymore than we have the ability to change the value of this integer. We're just getting copies of these values. We're getting a copy of this pointer. We're getting a copy of this value. We cannot change them. If the intent of DoWork is really to take this variable and point it to a different object, what we could do is pass by reference. Now when we invoke DoWork we have to use the ref keyword here also. It's very explicit when you're passing something by reference because it means what you're passing in could change, the value could change. And now if we run the test again then we'll see PassByValue, the test passes. So we're actually seeing this 5 value now. And what you can think of is you can think of that invoice object being out here. It initially has a ID value of 1. We're passing a reference to the reference inside of this method. You can almost think of this invoice variable pointing to this invoice variable. And changing the value inside but also putting 5 into the object that's out there on the heap and that's why this all works. And what would happen if we did the same thing with the integer. We'll add the ref keyword in the parameter list. We'll add the ref keyword when we're invoking DoWork. And now if you run the test yet again we'll see the text fail. And the reason is if we click on this we can actually get it to take us to the exact line of code, it's line 74, I'll click on that, is this assert. We're actually able to change the value of this variable inside of DoWork because it's passed by reference. So once again you can think of this working almost like this value gets a pointer to the memory locations that storing the integer value 1. We'll take about this a little more in a bit what's really happening behind the scenes. But now we have to change our assert. This should be a 3 now. We're actually changing the value inside of DoWork. Let's run the test one more time and we see that we're passing again. And just to be complete let me show you if I use an alt keyword down here then I have to invoke this with an alt keyword here. And if we build that right now everything still builds successfully. What I could do now is not initialize value. What I expect to happen is that DoWork will initialize value. I expect some sort of output from DoWork. Build still succeeds. But if this were a ref parameter now the C# compiler is going to be unhappy and say you're using a variable that hasn't been assigned yet, the local variable value because when we're passing by ref we expect that DoWork might look at the value of this parameter before it assign something else into it. So it expects it to be initialized. So we could just assign it a value and the build will be happy again.
Strings
Now that we have a good understanding of reference types and value types, let's return to the topic of the string type. I mentioned in a previous demo that strings are reference types and indeed that is true, however, the string can seem a bit magical at times because it behaves a little bit differently than other reference types. One reason for this is performance. We have strings everywhere in our software. Even if they're not in our code all the time everything that's happening inside of the .NET Framework is going to involve a lot of strings. For instance if you are writing a web application and emitting HTML to the client that HTML ultimately is represented in a string. Same with data base commands and the XML being pushed between web services. If there's one class in the .NET Framework that has to perform really well it's the string type. One reason the string type feels a bit magical at times is because it behaves like a value type. I'll show you a clear demonstration of this in just a minute. It's immutable. So once you have a string, a sequence of characters you can't change the value of that specific string that you've created. And when you check two strings for equality what happens in the .NET Framework is the runtime will actually perform a string comparison. It's going to look at the sequence of characters inside of two strings to determine if they're equal or not. For example in this there would be two strings, S1 and S2, they're both referencing the word vitamin. And usually when you use the equality operator the double equal sign on reference types the runtime essentially does an object.ReferenceEquals. It sees if S1 is pointing to the same object as S2. But with a strings what the runtime does is actually look at the sequence of characters in S1 and the sequence of characters in S2 and determine if they have the same value, are they the same string? Not the same object with the same value. I do want to point out that in many projects this code is found upon in projects that have to be sensitive to the environment they're running in, you generally do string comparisons and string equality checks using a very explicit call for instance here is S1.Equals, equals is a method on the string but in here it's from object type and the string class overrides equals to perform its own magic. But inside of here you can be very explicit about how you want to perform this comparison. One of the parameters to equals will allow you to explicitly specify if you want to perform a case sensitive check or a case in sensitive check. And you can also take the current culture into effect. So you can say obey the rule of Spanish or English or German or Hindi or whatever the user expects for their culture, take those rules into effect when you perform the string comparison. Let me demonstrate a common error when working in C# with string types. Here we have a test that is initializing a name variable of type string to the string Scott and you'll notice there's a leading space and a trailing space in that string literal. Then we'll invoke the trim method on that string instance, and you can see in IntelliSense that trim is documented as removing all leading and trailing white space characters from the current System.String. It would be reasonable to assume then given that document that we can write and assert and say that the following is true, that the name should equal Scott without the leading and the trailing space. We should have trimmed those off. Let's run this test and see what result we get, and we'll see that the assert fail. We didn't have a Scott with the leading and trailing space from here. Why is that? Well, remember that I said that strings behave like value types. They behave like value types because of the way the equality operator works in the sense that the equality operator actually checks what is inside of the object, the characters inside of a string instead of comparing object references. The equality operator typically when it's working with value types is comparing what's inside that variable. And that's just the way it behaves with strings too. But that's not the reason that the test failed. The other reason that strings are like value types because they're immutable. Not every value type has to be immutable but commonly a value type is going to be immutable like an integer. 3 is always 3 and 7 is always 7. A string Scott with a leading space and a trailing space is always a string Scott with a leading space and trailing space is always a string Scott with a leading space and a trailing space. We cannot change this. So what happens inside of the trim method or what the runtime will do is create a new string instance and with the trimmed value of the string. So it'll create a new string instance and return that. You'll notice that trim is documented as returning of string-- we have to capture the new string instance that it is creating and we'll sign that into name. And now if we run this test again we'll see that it passes. So just a word of caution anytime you're working with one of the methods on a string for instance let's look at substring, anything that looks like it would modify a string is not actually going to modify that string instance. It's going to create a new string. You'll need to grab it as a return value.
Boxing
There are two special operations that you need to be aware of when you're working with value types and these operations are boxing and unboxing. A boxing operation converts a value type to an object. That is it will take the value and allocate some memory on the heap and wrap that value inside of a System.Object that lives on the heap. Now instead of having a value type you have a reference type and the value is on the heap. This boxing operation happens implicitly, in other words you don't need to explicitly use some sort of keyword like box to get this to happen. You can declare a variable of type int, sign that variable loop, the value 42, and then if you try to assign that int variable into an object variable, what the runtime has to do is box the integer in order to get that into a reference type. So it goes out on the heap, allocate some memory, sticks the 42 out there inside of System.Object, and now what you have with O is essentially a reference to that object with the 42 inside. Another example would be invoking a method like DoWork and passing I as a parameter. Well, it turns out that DoWork expects a reference type variable. It expects a System.Object. So again what the runtime has to do a second time, this is one boxing operation, it has to box that integer again to create something on the heap. And now the value, this parameter gets to reference that object on the heap. One reason this is important to understand is that it can lead to performance in memory consumption problems. This is because we described a value type as being lightweight. Typically something you create to model things that are going to be used in large quantities. Things that are going to be temporary, things that are short-lived, and you create a value type because you don't want the overhead of memory allocation and then the garbage collector later has to come through in and clean things up when you're finished with those object. If it was just a value type there would be nothing to clean up. Because this happens implicitly you can run into problems where you have a large number of value types being boxed or one value type being boxed many times and you're just not aware of it. So here, this line of code and this line of code both created objects on the heap and it may not be obvious until you really study the program. Just be aware of those anytime that you're working with a value type and you're assigning it to a variable that is typed as a reference type or passing it to a method that has a parameter that is typed as a reference type. There's going to be a boxing operation involved. Unboxing is simply the reverse conversion, that is given some object that's actually holding a value type we can unbox it and store it as a value type inside of a variable. In this case what we're doing is we're going out and we're getting value and we're casting it to be an integer and now 42 will live inside of this I variable as a true value type.
The enum
When we were talking about string equality, we saw that there was a parameter we could pass to the string.Equals method that was a type string comparison. This was the second parameter to the equals method. There's also a compare method that takes a parameter of this type. String comparison is another example of a value type but this one is built using an enum. An enum creates a value type that's essentially a set of name constants. For instance here we have a type called payroll type and the name constants are contractor, salaried, executive, and hourly. The way you can use this is you can define a property of-- or a variable of type payroll type and you can assign that PayrollType.Salaried or PayrollType.Executive. You can also do comparison. So if e.Role is equal to PayrollType.Hourly. What the C# compiler is doing behind the scenes is just using an integer value but instead of using these magic numbers in our code itself for instance saying something like if e.Role equals 4 which isn't very readable we can actually have these named constants to represent those integer values. By default the firs member in the numeration will start with the value zero. However, we can change that behavior by explicitly specifying a value for this. So here we're saying contractor equals 1. Each success of constant if we don't explicitly set a value we'll have a value that is 1 greater than the previous constant. So in this example contractor would be 1, salaried would be 2, executive would be 3, hourly would be 4. But we could say executive equals 28 then we have 1, 2, 28, and 29. Enumerations are great when you want to give a nice descriptive name to some option that you need to pass to a method or set on an object.
Defining Types
To summarize our conversation so far, we've looked at two ways to create a value type. We see a struct definition or an enum definition. We know that's defining a value type. A reference type we know is what we get when we have a class definition. There's a couple other ways to create a reference type doing interface definition and also through a delegate. The built in array type in the .NET Framework is a reference type. I want to spend just a little bit of time talking about interfaces and arrays in this module. We'll come back to describe delegates in more detail in just later module.
Interfaces
An interface in .NET is an abstraction that allows you to group together methods, properties, and events and all of the members in the interface should be related to one another. To define an interface use the interface keyword and you can also set the accessibility of an interface just like you do with the class so you can make those public, you can make it internal. By convention the first letter in the interface name should be a capital I. It's not a compiler error if you don't follow that convention but 99.9 percent of the interface is written in the world today in .NET or have a capital I prefix. It just makes it easy to pick out what is an interface definition. Inside of here we're going to describe the operations that a message logger should perform. In this case there's only one method that's called LogMessage and takes them-- takes in message parameter. Interfaces are the ultimate abstraction because you are not allowed to provide an implementation or any of the members defined in an interface. So there's no implementation for LogMessage just a semicolon. You might think this looks like an abstract class. We'll talk about the differences between the two in just a minute. All the members that you define on an interface are going to be public and there's no way to change that. The idea is that a class or a struct will inherit from this interface and that class or struct must provide an implementation. So for example we could have several implementations of a message logger. Here's a class called FileSystemLogger, this is something I can instantiate and it guarantees that it will implement the IMessageLogger interface. So it provides an implementation of logged message, and presumably in here what the implementation would do is open a text file on the disk and write messages into that text file. You can imagine another class like the SQL Server logger or the SQL database logger that implements LogMessage and inside in the implementation it opens a connection to a database and writes messages into a table. The idea behind the interface is that the clients, the code that uses the message loggers, they don't have to know about FileSystemLoggers and DatabaseLoggers and WebServiceLoggers. All they need to know is that these objects implement the IMessageLogger interface that they have a LogMessage method and that's the only thing they care about, just invoking that method, passing along a parameter. There are a couple significant differences between an interface and an abstract base class. An abstract class can define members that have an implementation inside. An interface cannot provide any implementation for any of its members. Another significant difference is that classes in struct can inherit from multiple interfaces. You can only pick one base plus. So whether that's System.Object as the default base class or some other base class, you can only define one base class when you're implementing a new plus. However, you can pick as many interfaces to implement as you would like. This makes interfaces a little more flexible and less restrictive than abstract base classes.
Arrays
One of the important reference types built into the .NET Framework is the array. The array is a simple data structure. It manages a collection of variables and all of those variables have to have the same type. The syntax for declaring an array is to use the type that the array is going to hold followed by square brackets. It's what we're declaring here as an array called scores it's going to hold integers. We're going to construct a new array that can hold four integers and if I were to try to who assign a string or a double into one of the positions of the array I would get a compiler error. Arrays are always 0 indexed. That means that the first element in the array is element with an index of 0. So0 score's sub 0 would be the first score that's available in that array and a sub 0, sub 1, 2, and 3 would be four available scores. One of the other things that you can do with an array is loop through it using foreach construct in C#. So this is going through each score that's available in that array and computing a total score. Every array always derives from an abstract based class called array that gives its certain features like a length property so I can ask for scores.lenght that will tell me about this 4 in this example. What we have here is a single dimensional array, you can also have multi-dimensional arrays and what we call jagged arrays. We'll look at that in the demo.
Array Demo
Inside of this task we're creating an array of string and we're telling the framework that we want the array to hold 4 string elements that means we can index them into the array using 0, 1, 2, and 3 as index values. Once we populated the array with data we're going to invoke a method called ChangeName. And you can see the ChangeName takes a parameter that is a string array. Inside of ChangeName we'll walk up to the first element in the array and change its value from Scott to Allen. Then when control returns to our test we'll be able to say assert that the first element in the array is indeed Allen. And this is going to work because as I mentioned before an array is a reference type that means when we create the array we get a reference to an array of object that is stored on the heap, we're going to populate each one of these elements with the value that is also a reference so to reference to a string in this case. And it doesn't matter whether you're storing reference types or value types the array is always going to be on the heap. Therefore when we pass this array as a parameter, this parameter is going to reference that same object. When we change the first element of the array we're simply changing the value inside of this first elemental to point to a different string. And we're going to be able to see that change when we return to the test because it's looking at the same array object. Let's run the test and make sure this works and we can se that the test passed. One thing you need to be careful with when you're working with array is not to exceed the length of the array. For instance if I try to assign something into the array using an index value of 10 and I run this test what we'll see is it failed. If I double click on this we can see the actual exception. We got an exception IndexOutOfRangeException. The index was outside the bounce of the array and that simply the framework's way of telling us that we tried to get to something in that array that didn't exist, that creates an error condition. I also want to point out that there's an alternate syntax for initializing this array instead of using the 1, 2, 3, 4, 5 lines of code that we have here, I could replace that with a single line of code and use what's called a collection initializer. The C# compiler is smart enough to figure this out and say, "Okay, you want an array of strings, well, I see 4 elements here so I will create an array that holds 4 elements and I'll put Scott in the firs element and then Aaron and then Fritz and Matt. And this single line of code is equivalent to the five lines that we have before. Once you have an array constructed there's a number of interesting things that you can do through the array type that exposes a number of static methods for instance index of binary search. Of course binary search assumes that your array is sorted first. Let's try to use IndexOf so I can say IndexOf, pass in the array as the first parameter, pass in the value that I'm looking for. In this case I'll go looking for Aaron and I'll take the result of that which should be the index where it found that, then we can assert that we found Aaron at position 1. So index equals 1, let's run our test again and we'll see that passes. What happens if you look for a value that is not in the array? In that case you'll get minus 1 because minus 1 would be an illegal value to use as an index into an array since they're zero-based. One last thing I want to point out about the array and this will tie into our discussion of interfaces is let's look at the definition for an array. I can do that in Visual Studio by putting the type name on the screen somewhere and pressing F12 that'll take me to a metadata definition of the array. This looks like a class definition but it's really just helpful metadata that says you the available members in that array. But it also shows you the-- any base classes that it might inherit from and also the list of interfaces that it implements. In this case the array type implements a number of interfaces IClonable, ICollection, INumerable, all of these interfaces describe different behaviors that the array will implement and it also means that we could treat the array as a type of one of these interfaces. So for instance back in my test I can remove that array now inside of this ChangeName method. Right now the only thing I can pass in here is an array of string. Since I know that array implements IList, I could treat the array as an IList. And what I've done now is I've announced that this method will take anything that implements the IList interface. Everything will still work as it did before if we run the test that will still pass but we've made our method a little more liberal and what it will accept. It's no longer restricted to just arrays, it will take anything in the .NET framework that implements IList or any custom data structure that we might dream of that implements the IList interface, and that's the power of interfaces.
Assemblies
I didn't want to conclude this module without talking a little bit more about assemblies because all of these reference types, value types that we're creating ultimately they have to be packaged into an assembly. It's the fundamental building block .NET. We talked briefly about assemblies in the introductory module to this course but what I didn't show you in that introductory module is how to use assemblies that are defined in projects that are part of a solution. And this is a common scenario in application development. We know that every time we have a successful build in Visual Studio or from the command line, we're going to produce an assembly and that's just a file within exe or .DLL extension. Inside that assembly is going to be some metadata that describes the version of the assembly. There's also going to be information about all the types that are defined inside. And of course all of the code that we've written inside of method bodies that actually performs work that's going to be compiled into the assembly also. So for example if we look at our demo project I can right click on the project node and I can say open this folder in Windows explorer. We'll be opening up the root of our project. This is where the C# file exists that contains all of our code as well as the .csproj file that defines the project. Every time we do a build then the assembly will appear in this debug subfolder because we're building in debug mode. But cstypes.dll is the assembly that contains all of our tests. When we execute the test, Visual Studio has to load up that assembly, execute the code inside and evaluate the result. Of course all of the code required to execute those test is not contained entirely in cstypes.dll and that's because we're making use of other types like the array type, this assert class, this test method attributes. These are defined in other assemblies that we need to reference. So here you can see we have a reference to three other assemblies including system and system.core. It's very easy for Visual Studio to find our cstype assembly because it knows it's going to exist in this debug directory. But where is it finding these other assemblies? Where is it finding the system assembly? The system assembly lives in a place known as the Global Assembly Cache. This is a central location under the Windows directory where you can store assemblies and share them across any application on the machine. All of the assemblies that Microsoft shift is part of the framework class library are installed into the Global Assembly Cache. We also call it the GAC. One primary difference between assemblies that just lived in say the debug directory where our application is being built and assemblies in the GAC is that assemblies in the GAC require a strong name. A strong name includes a digital signature so that the runtime can verify that that assembly has not been tampered with. Before we can use a type that is defined inside an assembly we must load that assembly into our process that's executing. The easiest approach to doing this is just to establish a reference to the assembly from Visual Studio. The .NET framework will take care of the rest. It will load these assemblies on demand at runtime. That means if you reference an assembly but during the execution of your program you never use any of those types inside, then the assembly never gets loaded into memory. Plus you don't incur any overhead or in expense just in establishing that reference. The important part that I wanted to get to here is how do you establish references to assemblies that are defined in other projects that are in the same solution? So let's come into our cstype solution. I'm going to right click it and I'm going to say add a new project and I'm going to make a class library. We'll call this the InvoiceLibrary and click Okay so I can see we have two projects and a solution. Now let's go into our unit test. And what I'm going to do is take this invoice class and typically we wouldn't have this class define in the test that's a business object that we need in our application and our test are going to be in a separate assembly. So to simulate that kind of an environment I'm going to open up the C# file that Visual Studio automatically added to my project. And I'm going to paste the definition per invoice into that file. Now we no longer have our invoice inside of our unit test project. And if I do a build, you see we get an error. The C# compiler can no longer produce an assembly for cstypes because we've removed the definition of this invoice type. And it gives us a hint to the problem that asks, "Are you missing-- are you using directive or an assembly reference?" And in this case we're now missing an assembly reference. So if I right click on cstypes, I can select add reference and we get a list of other projects in this solution. All I need to do is highlight invoice library and click okay and we now have established a reference to invoice library from cstypes. Now when I do a build we still have a problem because we have an assembly reference but our invoice is now in a different namespace. So if we look at the namespace here, this is the invoice library namespace. What we're going to need to do is add a using so that namespace is actually in scope and the C# compiler can figure out what this invoice takes us. Let's do a build one more time and it's successful. We should still be able to run all of the tests in our projects. All of that works and if we look in the debug directory now what we'll see is the cstypes assembly is there but also all of the assemblies that are not in the GAC that its reference will be inside of here. So InvoiceLibrary.dll is going to be copied into this directory so everything can be loaded at runtime. It's quite common to break a large application down into multiple projects in establishing references between this projects will be important.
Conclusion
In this module we saw that every type in .NET falls into one of two categories. It is going to be a value type or it's going to be a reference type. If you want to create a value type that it's going to be a lightweight, it doesn't require an allocation in the heap then you probably want to use the struct keyword. When you wanted to find reference types, you can use the class keyword. We also looked at interfaces which define reference types but they are a little bit different because there's no implementation provided for an interface. We also looked at arrays and strings. We saw that both of these are reference types but strings are a little bit different. They behave like a value type. We cannot change a string value therefore strings are immutable. Also when we test for equality between two strings, the behavior is that the test for equality will examine the value of that string, it will actually go through and examine the characters inside of the each string.
C# - Events, Properties, and Methods
Overview
Hi this is Scott Allen of Pluralsight, and in this module we're going to look at the members that you can attach to a type in the C# programming language. This includes some familiar concepts that we've looked up before like methods and properties. But we're also going to introduce some new pieces. We'll drill into the details and the differences between fields and properties. We'll also look at events. We'll look at providing overloaded versions of the built in C# operators. We'll see how you can use an indexer in a C# and what that does. And we'll also talk a bit about constructors and destructors.
Methods
One type of member that we've already been adding to types in C# is the method. We know that methods define behavior. Because in between, the opening curly brace and the closing curly brace, we have executable instructions that might represent a computation or an algorithm or some sort of logic as executable code. We know we can control access to the methods that we add to a type by using keywords like public protected and private. And we know that every method has to have a return type. In case you're not returning a value from a method, you can use the void keyword. But you can also return an int or a string or some other type that you've defined as a class. Every method has zero or more parameters. In this case, we have a method called WriteAsBytes that takes a single parameter of type int, and that parameter named as value. The parameter list is enclosed inside a parenthesis and we could use comments here to keep including additional parameters. If you need to implement a method that takes a variable number of parameters, you don't know how many parameters the user will going to pass, there's a params key word that you can apply. And I'll show you how to do that in the demo. One thing you want to keep in mind for when we get later into this module is that every method has a signature. And the signature of a method consists of the method name and also the parameters. But the type of the parameter in any modifiers on that parameter are significant. So modifiers are the keywords that we looked at in the last module like ref and alt that changed pass by value semantics, that's the default in C# and to pass by a reference. It is the signature that makes a method unique. So WriteAsBytes that takes an int parameter would be a different method than a WriteAsBytes that takes a string parameter. One additional thing I want to point out is that the return value does not enter into the method signature. It's not considered part of a signature that doesn't differentiate two methods that have the same name. We'll return to that topic in a bit. Here in the demo project, I have everything setups that when we launch the program, it all instantiate this MethodDemo class which of course will invoke this constructor and call WriteAsBytes passing the value 32. Now WriteAsBytes is using a built in class in the .NET framework called BitConverter. It has a static method called GetBytes, we'll pass it in integer, it will give us back in array of bytes. We're simply going to loop through that array of bytes and write each value that we get in a hexadecimal format into the debuggers output window. If you're wondering what the magic is between the curly braces here in String.Format, then you'll want to go to the MSDN website. If you do a search for formatting numerical results, you'll see the magic codes that you can use to format numbers into a currency, into scientific notation and also into hexadecimal numbers. That's capital X or lower key x. You can also read those formatting overview which will give you a good idea of how you can control the string so they're going to be created when you use String.Format. But let's switch back and run the application. I'm going to press F5, and the application will launch. Now, in order to see the values that were written out, we have to go the Debug menu and go to Windows and click on Output, that will open up the output window that shows us a number of diagnostic messages including what assembles are being loaded into this process. But here's an output right at the very end, that's the number 32 using hexadecimal code. Imagine now that you want to implement WriteAsBytes so that you can give someone the ability to write out multiple integer values, and not by invoking this method multiple times, but perhaps, they pass in one value and a second value and a third value. But you don't know if you need 1, 2, 3, or 15 integers here. This is one of the scenarios where the params keyword can come in useful. When you use the params keyword, what you'll receive for this parameter is going to be an array. So now, instead of accepting an int, we're going to take an int array and we'll call that values. And of course I have to change the implementation of this method a little bit because we're not working with a single integer anymore. We're working with multiple integer values. So now we'll setup an outer loop that goes through each value in this incoming array. Convert it into an array of bytes and then write each one out. What's interesting is you'll notice that I do not have a compiler area here. I'm still passing a 32. What the C# compiler will do for us, the magic behind the scenes is that it's going to bundle this up into an array for us so it can pass it into WriteAsBytes. And if we press F5 to run the program, then in the-- the Debug window right now, we're just getting one integer written. What I can go on to do now is write out a 32, a 42-- let's do an Int16.MaxValue. We'll do an Int32.MaxValue. And you'll notice from the caller's perspective, what you're allowed to do is just keep passing parameters. They are going to be bundled up into an array. In the Intellisense window, what you'll is params, Int arraym, values. Now if I wanted to, I could explicitly pass an array. So for instance, this WriteAsBytes is creating a new array of integers with 2, 4, 6, and 7 and passing them into WriteAsBytes. So you can use either syntax here. But for in the application again, and make sure we get all of our output. And you can see now that we got a serious of hex codes in the debugger output window. The purpose of the debugger output widow by the way is, it gives you the ability to write out some diagnostic messages why your program is executing. It will give you some trace statements that you can review and examine if you're trying to figure out what's going wrong in the program. The reason I'm pointing up this params keyword is that you'll occasionally run across it, for instance, in the String.Format method. If we look at one of the versions of this method, you'll see it takes a params argument. And this means, you can pass as many arguments in the String.Format as you wish and it's the responsibility of the implementation inside of String.Format to piece everything together for you.
Method Review
Let's review what we've learned about methods so far in this course. We've seen both instance methods and static methods. Instance methods are the methods that you invoke via an object. So you need to instantiate an object from some type definition before you can invoke an instance method. That's different than a static method which has the static keyword place in front of it, those methods belong to the type not an instance to that type. And therefore, you invoke that method through the type name. An example is the GetBytes method of the BitConverter class that we just used. It's a static method. We don't need to instantiate BitConverter. We just need the BitConverter type name., and then the static method that we want to call. Two modules ago, we looked at abstract methods. We saw that we do not provide an implementation for an abstract method. And it function more as a placeholder at something that you have to implement in a derived class, therefore, an abstract method is implicitly virtual. A virtual method is simply a method that you can override in a derived class. This allows you to change behavior of objects that gives us the polymorphic feature that we need for object during the programming. I also briefly explained partial methods. These are defined in a partial class, and if you do not provide the implementation for a partial method, the C# compiler removes all calls to that partial method. One more type of method that we're going to look at in a future module is the extension method. I'll describe this when we get into the language integrated query section of the course.
Method Overloading
One useful feature of methods that you can take advantage of in C# is the ability to overload a method. This happens when you define multiple methods with the same name inside of a single type. The only restriction is that, each method requires a unique signature. Now if you remember our of discussion of signatures earlier, you'll remember that the signature includes the method name as well as the type and number of parameters. Therefore, the signature of WriteAsBytes that takes an integer is different than the method that takes WriteAsBytes with a double. These are two methods with different signatures, thus, they're allowed inside of the same type. When someone writes the code to invoke WriteAsBytes, it is up to the C# compiler to find and invoke the method that best matches the call. So if I invoke WriteAsBytes and I pass in a variable of type integer, the C# compiler is smart enough to figure out that I want to invoke this version of the method. If I'm passing in a variable that's of type double, the C# and compiler can configure out that I should call this version. If I try to pass in the string, I'll get a compiler AIR because the C# compiler won't know how to invoke either of these methods using a string variable. Here, inside of my Demo project, I now have two implementations of WriteAsBytes. One that takes in array of doubles, one that takes an array of integers, these are both marked with the params keywords. And now I'm invoking it twice. I'm invoking it once passing in some integer values. I'm invoking it a second time passing in some doubles. And if we run the program, what we'll see is that, we've invoked both methods. First, we invoked Writing integers, then we invoked Writing doubles. And I do want to point out that the implementation is pretty much identical for these two versions of WriteAsBytes, and that's because the BitConverter class, the static GetBytes method has overloaded itself. So it can take a Boolean and convert it into bytes. Can also take a character, a double, a float, an integer, and a long. Again, the C# compiler will figure out which method that you call based on the type of the variable that you're passing in.
Fields
Another type of member we've seen associated with the type definition is a field. Fields define the variables inside of the class. They define the state that's going to be part of an object or a type. We've seen both static fields which have the static keyword associated with them, and therefore, static field is owned by the type, just like a static method is owned by the type, and we've also seen instance fields which will be part of an object instance. We've seen access modifiers applied to fields, so we know they can be private, they can be protected, they can be public. And here's our read-only field. What's special about a read-only field is that you can only assign a value to this field in the declaration or inside of a constructor. So they could say _name equals and some value here to assign to that string. And we can assign to it in the constructor, but inside of any other method or property or piece of code that's in this type, it will be a compiler AIR if we tried to assign a value to _name.
Properties
A property is another type of member that you can add to a type and it's similar to a field in the sense that it's not something that you invoked and used the parenthesis, operators and passing parameters, it's something you just access using the .operator, so you can retrieve a value or set a value using the dot and the name of the property. But unlike a field, it does not denote a storage location. Instead, a property defines a get and/or a set accessor which is a little block of code that you can use to retrieve a value or compute a value or set a value. Properties are often used to expose some private fields that you might want to hide and just keep control over those fields. So only allow certain values to be set to that field. So for example, I have a private field here of type string and the name is _name. I'm going to expose that to a public property called Name. In the get accessor, I'm simply going to return that value. In the set accessor, when someone wants to set the value of name, I'm going to do some validation check so make sure that the string is not NullOrEmpty before I just set the name. The property gives me more control over what can go into name and what comes out of name. And unlike name, which when I defined this private field, the C# compiler has to set things up so that when an object of this type is instantiated, there is enough space reserved in there to hold a reference to a string, the property doesn't need any space reserved. Something else to know is that the access level for this get and the set are independent. That means, my get is going to be public because I have the public keyword here but I could use the protected keyword in front of my set operation to restrict that visibility. Protected of course means that the only code inside of this class or in the derive class would be able to set this name property. In addition, as this bullet point implies, you can have a get without a set. And that means, you have a read-only property or you can have a set without a get and you'd have a write-only property. So I could remove this set logic entirely, and the only thing that an external client would be able to reach is the get accessor, this would be effectively a read-only property. The C# language also allows us to use what is known as an automatically implemented property. This is when we have a property declaration and have only get; and set; with a semicolon at the end. In this case, defining this property is going to result in a storage location being set up to store a reference to a string, but this is because the C# compiler behind the scenes is going to create a field in this class. We're not going to be able to access that field directly. We don't even know its name, but there will be a field of type string to store the name reference that we can get and set here. This was a nice little syntactic shortcut that was introduced into C# 3. Events are something that we haven't look at yet so we'll spend a little bit of time here.
Events
Events allow a class to send notifications to other classes or objects that subscribe to the event. One of the perfect examples is the Button class, the Button class represents a button on the screen in a Windows Presentation Foundation Application, and when someone clicks on that Button, the Button object to itself will raise a Click event. Anyone who is interested in that Button Click event can subscribe to the event. And when the Click event is raised, that event will be transmitted to each of the subscribers, so that each have a chance to respond to that event and run their own logic and respond to the click. The Button is what we would call the publisher of the event and everyone who is listening for that event to raise will be the subscribers. Typically in .NET, we don't talk about an event being fired or an event being triggered, we talk about an event being raised.
Events - Delegates
To truly understand events, we first have to understand delegates. A delegate is a type in C#, just like a class defined to type and a struct define to type, a delegate defines a type. But this is a special kind of type that references methods. And if you've done any programming in C or C++, this is similar to a function pointer but it's type safe. The definition of a delegate looks like these code snippet. We're defining a public delegate using the delegate keyword, and the name of this particular delegate is WriteMessage. What we can do with WriteMessage is to clear a variable of this type and then point that variable to a method. And that method can be a static method or could be an instance method on some object. And then we can invoke that method to the variable. The type of method that we can point to is one that returns void and takes a string parameter. In some ways, a delegate definition looks almost like a method definition with this delegate keyword in here, but that's because we're defining the type of method that the delegate can reference. Let's say then, we have a Logger class that has a WriteMessage method that returns void and takes the string parameter. It turns out the name of this method isn't really important, that's the return type and the parameters it takes. In this case, this method is compatible with this delegate. And that means in code, we could instantiate a logger. We could create a new WriteMessage delegate and when we initialize that WriteMessage delegate, we pass in the method that we want it to reference. And you'll notice, logger.WriteMessage is not followed by a parenthesis because we're not invoking this method, we're just assigning the delegate to point to it. To invoke that method indirectly through a delegate, we essentially apply the parenthesis operators to that write delegate that will invoke whatever methods the delegate is pointing to. Here, inside of the demo project, we're going to work with the delegate just like the one we saw on that slide. That's a delegate that can reference a method that returns void and takes a string parameter. We're also going to work with two classes. There's the DebugWindowLogger that has a SendMessage method, and the BetterDebugWindowLogger that has a SendMessage method. Both of these methods have the same return type, both they got string parameter, both write to the debugger's output window. Now what we can do with this delegate is inside of another class called DelegateDemo. We can define a field of that delegate type. And inside the constructor for DelegateDemo, we can initialize both the DebugWindowLogger and the BetterDebugWindowLogger. We can now create an instance of this delegate and we could point it to the SendMessage method on either logger. So, log2.SendMessage or log1.SendMessage, either one will work equally well. Let's press F5 to run this project and just make sure we get some output in the debugger's output window. It's there where you could see Doing some work. There are several interesting facets to using a delegate. One is that inside of DoWork, all they care about is invoking this delegate. We invoked the delegate, pass it in some information. And ultimately, inside of DoWork, we don't know where that call ends up. Since it is a delegate, something magic is going to happen. It's going to invoke a method somewhere else inside of another object. We don't need to know which object. We don't need to know which method on that object. You can imagine for instance that inside of the constructor, we might use some configuration information that's given to the application to pick one of these two loggers and wire up this delegates so that reference is the one that are selected in the configuration. However, there's another interesting feature to delegates. Every delegate is what we call a multicast delegate. And that means that each delegate maintains an invocation list of all the methods that it should invoking when that delegates is invoked. In other words, if I say, writer and use the plus equals operator, and give it log1.SendMessage again, what I'm telling the writer is to invoke log1.SendMessage and it should also invoke log1.SendMessage. And it should also invoke log2.SendMessage. And just for good measure, we'll include log1.SendMessage again. Let's run the application and see what happens this time. Going to open that output window, and you'll see there were actually four method indications that took place when I invoke the delegate. It walked through the invocation list it had and looked at all the methods that were added into that delegate. So this is quite interesting. That means that we can invoke this delegate inside of DoWork and it could invoke not just one method in one object but multiple methods across multiple different objects inside this process. This means that if someone was particularly interested in what was happening inside of DoWork, we could notify everyone who is interested of what was happening inside of here. Perhaps, it's an important business transaction and we went to announce it to the world so that anyone who is interested in the work being performed inside of DoWork, we can let them know when it is happening. We can invoke this delegate and it could execute methods on several different objects. So let them all know what's going on and one could do logging, one could do auditing, one could send some e-mail, one could call a web service. But as it stands right now, this, that sort of feature is not very interesting. Because our delegate is private, no one from the outside can reach in and add themselves to this delegate. We have to wire up everything inside of our own constructor. It will be interesting if we could take this delegate and we could make it public. That means, objects that are outside of this class could walk up and say writer plus equals and then add their own method into it. This would really be interesting, because now, the constructor, we don't know who is interested in the DoWork method inside of our own class. It's all this other classes, the auditors and the ones that send the e-mail, they are the ones that know they need to hook in to this functionality. Unfortunately, by making this delegate public, the delegate is a little bit too low level of an abstraction to do this. One of the problems is that someone from the outside can just walk up and say, writer equals null. And what happens is that, that wipes out the entire invocation list that was already inside of that delegate. So effectively, one bad subscriber who makes some mistake or is malicious, can wipe out all of the notifications for all of the subscribers that already register themselves in this delegate. They had placed methods into the invocation list for this delegate to call. And this is where events come in. Because events are an abstraction over top of delegates that make them safe to expose from a class. So the only thing an event will do is allow you to add yourself to an invocation list or remove yourself from invocation list. And you can't touch anyone else's entries inside of that invocation list. What we'll do now in the next two slides is look at events both from the subscriber's perspective and the publisher's perspective.
Events - Subscribing
Anytime you're working with the class that has events exposed, you can walk up to the events on an object and use the plus equals operator to attach an event handler or use the minues equals operator to detach or remove an event handler. You can attach both named or anonymous methods. We haven't talked about anonymous methods yet. I'll show you what that is in just a moment. One type of object in .NET that consistently has a Click event as any type of Button object. And it doesn't matter if you're working in web forms, or windows forms, or WPF, they'll be a Click event and you can subscribe to that event and register an EventHandler. This is WPF codes, what we're doing is we're creating a RoutedEventHandler delegate initializing it to another method called _submiButton_Click and the type of method the RoutedEvetntHandler can reference is a method that returns void and takes some object parameter and a RoutedEventArgs parameter. Inside of the event handler then, we're free to do whatever we need, we can pop up a dialog box, we can perform some calculations, we can save stuff into a database. Typically, what you'll do is orchestrate some business objects to perform some sort of work in response to that Button Click event. And what we have here is a common pattern for events in .NET. The first parameter is always object, it's going to represent the sender, the object that is racing this event. You can cast the sender parameter to a particular type. In this case, the sender would be that Button object. We could cast sender to a button, and interact with that Button, perhaps disable it or change and the color. And the second parameter in an EventHandler is always a class that is derived from a base EventArgs class. And oftentimes, the event arguments here will include information about the event. For instance, in a mouse Click event, you can retrieve the coordinates, the X and Y coordinates of where the mouse click occurred. Here, inside the demo project I've defined a simple application that includes a button and a text block. The text block currently shows the name of a dog, a popular dog's name is Lassie. What I want to happen is when the user clicks the button, I want to change the name that is displayed inside of this text block. Although there are actually a couple of ways that you can wire up an event to this button, when you're inside a Visual Studio, you can click on that button to give it focus and then open the Properties window. Inside the properties window there is an Events tab. If I come here, I can get a list of all of the events that this button exposes and there's quite a few everything from DragEnter to GotKeyboardFocus to Initialized. I'm interested in the Click event, I can double click here, and Visual Studio will automatically generate some code for me. This is my EventHandler. This the method that, that will execute when someone does click that button. And what Visual Studio has done is, Visual Studio has gone into the mark up, the XAML file for this. And they have assigned the Click event inside of the XML, inside of the XAML that defines this main window. This is one way to execute a Button Click event but I want to show how you could do this manually. So, let's go into MainWindow.xamll.cs, this is the code behind for the application. And I'm going to remove this even handler. And let's come into the MainWindow_Loaded with that. This is setting up some information for the screen. But what I can do is I can walk up to my button object, now I should point out that my button has a name x:Name. And what happens when you give an object and XAML a name is you can access it from the code behind. So _button shall also be a field that is to find as part of my class. And I should be able to say _button. In here, I can find the Click event and now I'm going to type plus equals. And Visual Studio does something interesting here too. It knows you want to create an event handler. If I just press tab, it will generate that boiler plate code that I need to create the routed event handler object. And then I tab again, it will go ahead and generate a method to handle the event. So what I did here was type plus equals and then hit the tab button twice, and I have this code generated for me. Now, first of all what is a RoutedEventHander? I'm going to put the cursor on RoutedEventHandler and press the F12 key, this opens up a metadata definition of what that type is. So this is an actually the source code that Microsoft wrote, but it's something that, in the case of a delegate, it's pretty close. So we can see that RoutedEventHandler is a delegate type, and you can point those to any method that returns void and takes some object and RoutedEventArgs parameter. From here, I could press F12 on RoutedEventArgs, and this is another class that Microsoft has provided. It derives from the EventArgs and it includes some specific information about this event. But coming back to the source code, all I'm simply doing is creating a delegate, initializing it to point to this event handler and then I'm adding it to an event that's been defined by the button class and WPF. Inside of the Button Click event, what I could do, as I could say, animal.Name equals Beaker which is a cat name. And what I'm going to do, is I'm going to set a breakpoint here, by clicking out here in the bar. And then I'm going to press F5 to run the application again. Then let's click on the button. You can see we got to our break point, we're about to set the animal's name to Beaker, a cat. And if I press F5 to leave the application run, you'll see, we're still displaying Lassie. Now, this isn't because our EventHandler didn't work. This is because of something else I want to show you after we look at the next slide.
Events - Publishing
As we we're looking at how to subscribe to a Click event in the WPF, we saw some of the common patterns that you'll need to follow when you want to publish an event. One of the first steps in publishing an event is determining what information you want to pass along to everyone who has subscribed to an event. That information will determine the type of your event arguments. This is the second parameter to every event. You can create your own custom event argument type or you can use a built-in type. Either way, you're ultimately going to be working with a class that ultimately derives from the base EventArgs class. We saw this in our demo application with WPF. It defines a RoutedEventArgs class that derives from EventArgs. It includes some additional information on top of EventArgs that you can find useful and processing a WPF event. You can derive directly from the EventArgs, or if you find RoutedEventArgs already useful, you could derive from it. Here in the slide, we're simulating the type of information we might want to publish when a name or an object changes, when some name property changes. So somewhere, we have a type defined as NameChangingEventArgs that we derived from the EventArgs. You could see we can instantiate it. We can set some of the special properties that were built into this type, so we can publish what is this newName that we're going to take, what is the oldName that we're going to replace. We can even have a flag inside of our event arguments that allows a subscriber to set some information that we can retrieve later perhaps cancelling this operation. That's a common pattern that you'll see in some places of the .NET framework. Once you have your event arguments established, then you can define a delegate or use one of the built-in delegates. The delegate is going to define the type of method that can subscribe to an event. So for example, in our demo project, the WPF, it defines a RoutedEventHandler delegate and can point to any method that returns void and then takes an object in RoutedEventArgs parameters. This step can be optional when we get to a later module covering generics. We'll look at event handler of T which can be used to create an event using custom event arguments without explicitly defining a delegate. Once you have you event arguments defined and a delegate, then you can define the actual event in your class. For instance, in this code snippet, we have a public event that anyone can walk up and subscribe to. Its name is, NameChanging and its typed as named NameChangingEventhandler. This would be the delegate that you have defined. Now you don't need to do anything special to allow people to subscribe or unsubscribe from this event, just make a public in the C# compiler, and the .NET framework will take care of the rest. But you do have to raise the event at the appropriate time. When the name of these object changes, inside of our object, we might invoke a method called OnNameChanging. Its responsibility is to construct the event arguments, set their properties correctly and then raise that event. And you can see, raising the event looks like a method invocation. But in this case, NameChanging is our event that takes a sender parameter in our event arguments. Also notice that we'll make sure it's not equal to null, that means, no one has subscribed to this event. And if you try to raise the event in that scenario, you'll have a null reference exception. When we were lasting our demo project, we had a bit of a problem. Although, we successfully subscribed to the Button Click event programmatically, and we solved it using a break point and debugging through the program, we were executing this method when we click on that button in the UI, the display in the WPF was not updating when we changed the name of our animal. It started of as Lassie, we clicked the button, and it didn't change. And the reason is, that we're using data binding and Windows Presentation Foundation. And when used data binding and you're changing data, you need to raise an event that tells the WPF when something has changed. That way, it can efficiently redraw the screen at the correct time. Now, it turns out, we can't just raise any event. WPF is looking for a very specific event. And the class that we are binding against is this Animal class, that's one we're data binding against. When you want to raise events to tell WPF that something changed, you want to implement INotifyPropertyChanged, that's an interface. If we hit F12, we see that all that defines is an event. It's going to be public event called PropertyChanged. That delegate type, the type of method it can point to is the PropertyChangedEventHandler as something that returns void, takes an object and also takes a PropertyChangedEventArgs instance. Now if we look at PropertyChangedEventArgs, this will be like the costume class that you have to define the past long pieces of information relate the only piece of information that we're worried about passing along in here is the PropertyName. What is the name of property on this object that is just changed? That way, WPF can look at that and update the screen. All right. So we're going to implement this interface. I'm going to just hit Ctrl period and I'll get the shop down list that will go ahead and add members from INotifyProperyChanged into my class. And there is my PropertyChangedEvent. This is the event that I need to raise when name changes. So, I have to rewrite my property a little bit. Right now it's an automatic property with one of those magic hidden backing fields behind it that the C# compiler will generate. I'm going to change this so that I explicitly declare a backing field. And in this case, I just call it _name and then in my property, I'm going to have a get that returns_name and they set that if the name and the incoming value are not the same, I'll set it but then I also need to raise the PropertyChangedEvent. What I'll do is create a method called OnPropertyChanged. And I'm going to use Visual Studio to generate a method stab for me by again hitting Ctrl dot, and I get I get that dropped down. What this will do is, no matter how many properties I have, I can always call the same method and just pass in the one piece of information that's always different which is the property name. So, we'll call this propertyName. When we invoke it from the name property, we'll pass in name. Inside of the method, I can say if PropertyChanged, it is not equal to null, then we'll creat some ProperyChangedEventArgs passing in that propertyName. And the way we raise the event is to say PropertyChanged, we'll pass in this as the sender and we'll passing args that we just created as the event arguments. So now, every time we set the name of the animal, the Animal class should raise the PropertyChangedEvent, that will be signal to WPF that something is changed. It'll examine it's bindings, compare that to information pass in the event. Look up the new value for the name and display it on the screen. So let's press F5 and try it out. I'll hit Click me. You can see, we hit our break point, we're going to change the name of the animal, I'll press F5 to continue execution. And we now have the updated information on the screen. One of the beauties of events is how things can remain decoupled. Notice how we can subscribe to the Button Click event without the button knowing who it needs to communicate with. It just needs to raise that Click event, someone is going to handle it and perform some sort of custom logic. At the same time, our code is a bit decoupled from WPF. We don't need to know exactly what widgets on the screen are bound to this name property. We just need to be responsible for implementing INotifyPropertyChanged. If someone does changed this property, we raise an event that WPF will be listening for. And everything is working in beautifully decoupled way. There's a couple additional pieces of information I wanted to give you before we left this demo. First, I wanted to clarify the use of "this." "This" is reserved word in C# and "this" always represents a reference to the current instance of the class. So anytime you're inside of an instance method or an instance property, you can use the "this" keyword to refer to the current object. "This" is unavailable inside of a static method or static property, because there is no object instance in that case. Remember static properties and static methods are always invoked through the typening, instance methods and instance properties are invoked through an object instance. The second piece of information I wanted to give you is that, I promise to tell you about anonymous methods. Just before we talked about anonymous method, so I'm going to point out that the C# compiler is really good at converting to delegate types and creating them. So for instance, instead of explicitly specifying that we need a RoutedEventHandler, we can just use +=_button_Click and the C# compiler is smart enough to create a delegate force and assign it to this Click event. The code here works just like the code that we had previously but it's a little shorter. Now you might be wondering, why then do I need to define an entire method here just to say, that animal.Name equals some new value? Why couldn't I just take that and place it sort of inline here. And it turns out we can, but we need to give some additional information to the compiler. So we need to tell it that what we're doing is creating a delegate and we need to define the parameters that are going to come in to this piece of code because what this really is now is a method. But instead of being a method that has not a name like _button_Click, it's an anonymous method. It's still a block of code, but this block of code has no name. The only place is going to be accessible is through this Click event. And the code that we have now will work the same, but we've saved ourselves from writing out an entire name of method to perform that behavior. There are times when the syntax is preferable. It's all trade-off between readability and functionality. And we're going to revisit this topic and see how it could make this anonymous method even shorter when we talk about link in this course. And we're going to revisit this topic of anonymous methods and little blocks of code when we get to the functional programming module.
Indexers
At this point, we've covered the most important members of a type. You'll probably find that in software development in C# that 80 to 95 percent of your time is set up defining fields, properties, implementing methods, and adding events to a type. But there are additional members that you can add to a type, for instance, an indexer. An indexer allows you to index into an object much like you would index into an array, so using the square brackets. Here we have a Zoo class that has a public indexer that returns an object of type Animal. This is an indexer because it's using the "this" keyword. So the "this" keyword has a different meaning depending on the context that it's used in. It's like an overloaded keyword. In this case, when you're using the "this" keyword and the square brackets on a member, it's defining an indexer. This is defining the parameters to the indexer, so we're saying that you need to pass in an integer. And then we implement the indexer much like we would implement a property. We can have get that returns something when a client accesses the indexer, and we can have set that accepts a value whenever the client is setting something through an indexer. In the case of the Zoo what we may have behind the scenes is a private collection or a private array of animals that we're going to give access to that collection through an indexer that we exposed. I also I want to point out the indexer can take multiple parameters so they could have a pass in an int and a string and another int. Typically, it makes sense just to take a single parameter. Using an indexer would look like this codes in a bit given some object of type Zoo, we can use the square brackets passing in index parameter and expect in this case to retrieve an animal. You can see that by defining an indexer, we're giving clients array like access into the private state of some class.
Operator Overloading
In C#, you can overload operators. This means that you can define the behavior for the addition operator on your type. And you can do this for most but not all of the operators. But you can certainly do this for addition, subtraction, multiplication, division, incrementing, decrementing, checking for equality, and inequality. You do this by implementing a static method, in here, we have value type named Complex. We're going overload the addition operators so that we can add two complex numbers. It's a static method that uses the operator keyword. And then the operator that we're going to overload. This is a binary operator so we need two parameters, both the type Complex and we'll return a new Complex number. To use the operator, we just need two complex numbers and then a simple expression with the addition operator. You do want to be careful and pay attention and follow what we call the principle of lists surprise. Because as a developer, when I read this line of code, I'm going to make assumptions about what happens when I use the addition operator with two complex numbers. I'm assuming we're going to add those two, and with Complex numbers, that make sense. Since there is no method name here, you want to stick to the true intent of that operator which is addition in this case. Operator overloading is quite common in value types when you're trying to represent something that is additive. Perhaps it's a special monetary value that you're modeling in your software and you want the ability to take two objects of those types and be able to add them to produce a result. Where things can get sticky is when you tried to get clever and use these operators to implement behavior on objects where the behavior is not really something that will be immediately obvious. For instance, overloading the subtraction operator when working with two objects that represent files on the file system. But when dealing with a complex number, I found would have a pretty good idea of what would happen.
Conversion Operators
You can also add one or more conversion operators to your type. A conversion operator will convert an object from one type to another. For example, if we have a type called Price, we can write a conversion operator so that the C# compiler will automatically convert the integer value 3 into an instance of price. And we can do this either implicitly or explicitly. Implicitly, the C# compiler will just magically do this behind the scenes. If we want this conversion to be explicit, you need to provide a cast operator. Conversion operators are implemented using static methods. The name on the method will be the same as the constructor, the name of the type, so in this case Price. But we'll have the operator keyword here. You can use the implicit keyword to have the implicit behavior. There's also an explicit keyword that you can use here to force everyone to use a type cast when doing this conversion. And the parameter to this method will be that the type of object that you want to convert from, in this case, an integer value. Inside the method, you'll do whatever work is necessary to take, in this case, an integer value then convert that into a price that you return.
Constructors
Constructors are a special member that you can add to a type. We've already seen constructors in this course, but I want to give you some additional points of information. First, we need to differentiate between instance constructors and static constructors. Static constructors will have the static keyword in front of them, there can be only one static constructor on a given type, and a static constructor does not have an access modifier on it. So you cannot use the public or protected keyword. And that's because there is no syntax to explicitly invoke a static constructor. A static constructors automatically going to be executed by the runtime to initialize a type before any of the code that's going to use that type executes. The runtime figures that out and it also ensures that the static constructor will only execute ones during the life of the entire process for any given type. This is different than an instance constructor because you can have multiple instance constructors, you can overload them as long as the number of parameters are different or the types of the parameters are different, the C# compiler can differentiate between multiple constructors on a class. And as we've seen, our constructor doesn't have a return type. It's not truly inherited, but you can use the "this" keyword or the "base" keyword to pass control to another constructor that's been defined. Use the "this" keyword to pass control to another constructor that's been defined on the same type, and use the "base" keyword to pass control to a class that you have inherited from, a constructor defined in that class. We'll take a look at this in the demo project in just a moment, but I also wanted to talk about variable initializers. Variable initializers are great when you want to construct an instance of an object and set some property values right away. For example, instead of saying NameChangingEventArgs equals new NameChangingEventArgs. And then having code that says args.cancel equals false, args.newName equals some value, and args.oldName equals some value. We can simply use the curly braces. Instead of saying args., we can just use the name of each property and the value we want to assign to that property. Variable initializers can help you remove some of the noise that might be involved in the code that has to construct and initialized a new object with some simple values. Here, inside the demo project, I've added a static constructor to the animal type. You'll notice that it doesn't have a return type. The name of the static constructor matches the name of the type. It's using the static keyword, and there's no access modifier. So we're not saying that this is public or internal. I also have two versions of the animal constructor. So one version does not take any parameters. And we'll do in this case is pass control over to another constructor we have defined that takes a string parameter. That string parameter is expected to be the name or pass along anonymous as the parameter for the name. It's inside of this constructor where we'll increment a counter that's keeping track of the total number of animals we've constructed. And that's done using a static field of type integer. That field was initialized to zero inside of our static constructor. If I run this application, you'll notice I'm constructing a couple different animals here. But the static constructor is going to execute before any of the instance constructors execute. And that's simply the framework and the runtime working together to ensure that type initializers a.k.a. the static constructors always execute before you start using any other static members of that type or instance numbers of that type. I'm going to press F5 in our inside of the animal constructor. This was an animal constructor without a name so its name is anonymous. I'm going to press F5 again. And you can see where it's constructing another animal, Animal2 and notice that the static constructor was early invoked once.
Destructors
C# also allows you define a destructor on a type. I'll (inaudible) where we could spend a long time perhaps an hour discussing all the intricacies of destructors. But I'm going to spend a little bit of time here to just give you the general idea. A destructor is designed to clean up an object instance. But what you have to remember about destructors in C# is that memory is managed. So you're never going to write a destructor to clean up memory. The CLR includes a garbage collector for just that purpose. Much like a static constructor, you cannot overload a class destructor, you cannot explicitly invoke a destructor. So there is no delete keyword in C# like there is in C++. The only time you're really going to be defining a destructor in C# is when you need to clean up and release unmanaged resources. Since memory is always managed by the runtime, unmanaged resources would include things like Windows file handles. So perhaps, you've written a class that is P invoking or directly going into the windows API and giving back some Kernel Data Structure or a pointer to something that is inside of Windows. This is something that the .NET framework doesn't understand, doesn't realize, won't clean up for you, that's when you would need to implement a destructor. The best practice when you do need a destructor is to always implement IDisposable, that's interface that forces you to implement a disposed method that a client use to clean up resources early before the destructor has to run. And if you want to read more about destructors, how to implement them, in what scenarios, when you need to implement one, I've pointed to an article here on the MSDN library. The syntax For implementing a destructor is to use the type name but preface it with the tilde symbol. The destructor is not going to take any parameters.
Summary
In this module, we've looked at all the members that you can add to C# type. And what to keep in mine is that, all these different members are really used to craft an abstraction. And the goal of that abstraction is to meet the needs of some specific goal. ( Pause ) You can use fields and properties and to represent state inside of an object. You can provide methods that defined the behavior for that object. And now we've also seen events that allow an object to notify anyone in the outside world about something that's happening internally inside of that object. ( Pause ) We also looked at indexer somehow to overload operators. But remember, use caution when you're overloading operators, you've really want to stick to the true intent of that operator and not try to force it into some scenario that might be ambiguous. If you're in that situation where you feel like an operator might not be the best fit, then just fall back and implement a method that has a very clear name and a description of its purpose. ( Silence )
C# - Flow Control and Exceptions
Introduction
Hi, this is Scott Allen of Pluralsight and in this module, we're going to look at Control Flow in a C# application. Specifically, we're going to be looking at the keywords and constructs available in the language to perform branching, to iterate across the collection, to jump to different points in an execution path, and finally, we'll look at error handling. That is how to throw exceptions, how to catch exceptions and how to create new custom exceptions.
Branching
Conditional branching is something that we've already done in the demo projects for this course but we haven't stopped to dig into the details of the if statement. The if statement selects a statement for execution based from the value of some boolean expression. So age is less than or equal to 2, that expression is going to return true or false. If that expression returns true, the if statement will execute the statement that immediately follows it. Notice that I don't need to use curly braces to surround the statement, but it's generally considered the best practice to do that because it makes the code easier to maintain and a little more readable. The curly braces are required if I want to execute multiple statements when this expression returns true. That's the only way I can include them inside of that if conditional check. When this expression returns true and I invoke this method afterwards control will continue with the next statement. If this expression were to return false, in this case, we have an else if. So in this case, we'll check the second expression as age is less than 21 and if so, we'll invoke this method and then continue execution. We also have an else here with no if conditional, so if the age is not less than or equal to 2 and it's not less than 21, then we'll always invoke this method ServeDrink and then continue. Note that the curly braces are not required either, but again, it makes the code little more readable. And speaking of readability, it's also possible to nest if statements. So the code that would be here where the comment is would only execute if the age variable is less than or equal to 2 and the name is equal to Scott. One thing to be careful with when you're nesting if statement particularly when you have else clauses and if statements, else if statements inside of here is the pyramid of fact. And that's when your code just sort of grows to the right, the indentation because you have all these nested conditional checks. That can make code a little more difficult to read and sometimes in those cases, it might be better to extract things into a method that can make these checks or to combine things with an end operator. So we could have written this as if age is less than or equal to 2 and name is equal to Scott. Closely related to the if statement is the conditional operator. This is the operator that consists of a question mark and a colon. It's also sometimes referred to as the ternary operator because it comes is three pieces. The first piece is an expression that needs to return true or false. So age greater than 20, and then the conditional operator will return one of two values based on the evaluation of this expression. If this expression returns true, we'll return the value that is on the left hand side of the colon. If this expression returns false, we'll return the value on the right hand side of the colon. So in this case, if age were to be 19, this would be false, the string pass would be assigned the value nopass. The ternary operator or the conditional operator is sometimes useful when you just need a really quick conditional check to assign one of two different values. The values here just have to match the type that you're assigning to. So in this case, we have two string values but this could be integers or two different objects or two different enumeration values. Here's another example of branching inside of a demo project. We'll walk up to the system.environment class that tells us information about the environment that we're executing inside of like the operating system version and the ProcessorCount. So the ProcessorCount is less than 2, we know we're on a single processor box and then we're going to use Environment.Is64BitProcess with the conditional operator to assign one or two text values, or either running on a Single processor or the 64 bit process, or if this is false, that means we're running on a Single processor as a 32 bit process.
Switching
The C# language also includes a switch statement. What the switch statement allows you to do is branch the execution path to a set of statements that are inside of a case statement and it does this by matching the value of the key statement against the value of a variable that you specify here in the switch. Note that the type of value that you can use here is restricted to a certain subset of types. You can use integers, characters, strings, enumerations but the values that you specify here must be compile time constants like the string literals. In this case, if the name is equal to Scott at runtime, then we'll invoke the ServeSoda method and then we'll continue after the switch statement. Note that you include as many case statements as you like inside of here to match against different strings in this case, but no two key statements can have the same string value. Once a case statement is selected; execution begins and continues until it reaches a break. Once we reach a break, execution will come out of the switch and continue with the statement afterwards. Unlike C++, there can be a no implicit fall through. So in C++, you could omit a break, in that way in the case of Scott, you could ServeSoda and ServeMilk and so fort, but in C#, that would be a compiler error. If this value does not match any of the case statements that are in the switch, then the default path can be chosen, but note, you don't need to have a default label so this is entirely optional. In this case, if we didn't have a default label and the string did not match either these two case statements with some place, skip over execution and continue afterwards. In the demo project, I'm switching on a type Environment.SpecialFolder. This is an enum type and specified by Microsoft and represents different special folders on our file system like the My Documents directory. Notice right now, I have a compiler error, it says Control cannot fall through from one case label to another. That's because I need the break statement here after every case label even if it looks like control could not continue any farther, the C# compiler is unhappy without the break statement here. And earlier, I said there can be no implicit fall through so why do I have three cases here that always call a Console.WriteLine looks like a media folder. Well, this is perfectly legal code. I can have all three cases transfer our control to this Console.WriteLine. This is okay as long as I don't have another statement inside one of these cases that tries to implicitly fall through. So we might try to say, "Looks like a music folder" and also "Looks like a media folder" but again the C# compiler will be unhappy because we have statements being executed but no break. Put the break in and the compiler is happy, it can build and execute this program.
Looping
There are four statements for iterating in the C# language. In this slide, we'll take a look at three of them. The first is the four-statement which consists of an initializer, a condition and an iterator. The for statement begins execution by executing any statements that are specified in the initializer and these statements are only executed once. No matter how many times you are looping, this executes only once. Then before any statements are executed that are inside of the for statement, the condition is evaluated. The condition is always boolean expression that has to return true or false. If the expression returns false, then we do not execute anything inside the for loop, we continue execution with the next statement. But if the condition evaluates to true, we'll execute the statements that are inside of the for statement. Now, these again are optionally surrounded by curly braces in which case only the next statement has executed, but generally for readability, surround everything that you want to be executed inside of a loop with the curly braces and this will continue as long as this condition returns true. You can say that a for loop will execute zero or more times because this condition is evaluated before the first pass through the loop. After the statements inside have finished executing, the for loop will execute that iterator. In this case, it will increment i then it will check the condition again. And if it's still true, we'll execute these statements again. The while statement is another way to loop zero or more times in a C# application. In this case, the while statement evaluates the expression and if it returns true, it'll execute the statements that are inside of the while loop. After it's finished to executing, the condition will be evaluated again. At some point, it should returns false unless you're trying to write an infinite loop and when the expression returns false, control resumes at the point after the while statement. Another alternative is the do statement. The do statement always executes one or more times. You're guaranteed to execute the code inside of here at least once because the primary difference between a while and a do while statement is that in a do while, the condition is checked after all the statements execute. So you're guaranteed to have control pass through here at least once.
Using foreach
The fourth looping construct in the C# language is the foreach statement. This is where you specify foreach, a local variable, the keyword in, and then some expression that represents a collection, because foreach is always going to enumerate through the items inside of a collection. The embedded statements in here will see each value that is inside of the collection. In this case, it's in array of integers. This might get you asking the question, how does the C# compiler know that this is a collection? We can see ints in array of integers but what is the C# compiler looking for specifically? Is it looking for a certain base class, for instance? Actually, what the C# compilers doing, it's looking for a method on this variable code GetEnumerator that returns something derived from IEnumerator, and if it finds that method in that return type, it will happily give you the code to execute this foreach statement properly. An enumerator is something that knows how to walk through a collection whether it be in an array or a list or a hash table or a dictionary, and all of the collection classes in .NET expose a GetEnumerator method. That includes arrays as well lists. Essentially, what the C# compiler is doing for you when you rate a foreach statement is that it is generating the code to first go up to that collection and get the enumerator that can walk through each element and then while the enumerator can move to the next value, you can execute the lines of code inside the foreach where the value of a local variable that you specified in the foreach statement is the value of the enumerator.Current property. So these two pieces of code are equivalent as just that the foreach gave us a very nice syntax that we could use to enumerate the collection. In the demo project, I wanted to show you a couple of examples of using foreach. First of all, there's a code snippet in Visual Studio that you can use to construct the foreach. Just type foreach and then tab twice, that will automatically expand into a code snippet where you can fill in information about the type of local variable, so we can say this is going to be something and we're going to try to iterate through an x. Now x is just an integer, so you can see that we get a compiler error that foreach statement cannot operate on variables of type int because it doesn't have a public definition for GetEnumerator. Remember that's the key that the C# compiler is looking for. So that foreach doesn't work, but if we try to enumerate through in array list of foreach, the C# compiler is very happy about that. One rule about foreach is that you cannot modify the collection that you are trying to loop across. So in other words, let's say that we we're writing these loops that we could take out all of the odd numbers with the array list. I could write something like this, if number modular 2 equals 1, so we try to divide it by 2 and we get a remainder of 1, then what I'll try to do is walk up to the numbers collection and then tell it to remove this number. Let's build that application and then run it with a debugger and what's going to happen is we're going to get some output but then we get an exception. And the exception is that the Collection was modified; enumeration option may not execute. So once you have modified a collection, your foreach statement is going to step dead in its tracks and say, I can proceed now further, something has changed out from underneath of me. I'm going raise an error condition. We're going to be talking about exceptions in just a little bit. Something else to be aware of that a foreach is automatically going to try these conversions. Whatever type that's in this array list, the foreach loop for each item of that array list, it's going to try to convert something into an integer. And one of the dangers of using an array list is that you can put anything in here, you could put an object, you could put in a string. If we really want this to be an array list of just integers, we'll talk about ways to do that when we get to the generics module in this course. But for now, let's run this program again with the string here just to see how it behaves and I'm going to remove this code that is removing numbers because we already know that that creates an error condition. You can see that we got up to the number 10 and then we get an InvalidCastException. So the code that the C# compiler is generating is trying to pull each member out of that array list and then because we have our local variable here typed as integer, it's trying to cast that value to an integer, when it gets to the string that fails and it throws an exception. So those are two issues to be aware of with the foreach. First of all, don't modify the collection that you're trying to iterate through. Secondly, be careful when you're using a foreach with one of these collections that doesn't enforce the type of object that is allowed inside of the collection.
Jumping
The jumping statements in C# like break, continue, goto, return and throw allow you to control the execution path of a program, but unlike the if statement and its friends which evaluate some boolean condition to branch the execution path, these jumping statements unconditionally jump to some target. We'll be talking about break, continue, and goto now. We'll talk about return and throw a little bit later in this module. We've already seen break, we know that we can use that inside of a case label of a switch statement, in fact, that's required there, but you can also use a break statement inside of a while loop, a do, a for, or foreach statement. For example, here's a foreach statement that's going to loop through some collection of integers and inside of here, if the age is equal to 21, we're going to break out of this for loop. Essentially, if the age is equal to 21, even if there are more items left in that collection, we're going to stop execution of this foreach loop and continue execution on the statement that is after the foreach statement. Continue is similar, except that instead of breaking out of the foreach statement, we're simply going to cut off executing anything after the continue statement and go through the next iteration of the loop. So in this case, if we encounter an age equal to 2, we're going to continue the loop, we're not going to execute anything that follows or we're not going to jump out of the foreach statement either. Essentially, the continue statement starts a new iteration and you can use it inside of a while, a do, a for or a foreach statement. Finally, there's the goto statement. Goto has always been a little bit controversial. Well, you can use the goto to do is jump to another statement that is marked by a label. So in this version of the foreach loop, if we encounter age equal to 2, we're going to jump execution down here to this label with the name of skip, essentially jumping over any code that was in between. Gotos are generally considered evil, and then 10 years of .NET development and many years of C++ before that, I've never been in a situation that required a goto statement. (Inaudible) widely regard as it's making the code harder to read because execution is jumping around and it's harder to follow. And I've always been able to rewrite logic that I thought might require goto using some other branching instructions to achieve the same effect.
Returning and Yielding
The return statement is something that we've been used many times in the demos of this course, but I do want to point out that you can use a return statement with a void method. So typically, what we've done is we'd have a method that return to a string or an int or some type of object and we use a return statement to return a three or the value of some variable, some object back to the color. But it is legal to use return when you have a void method, you're just not allowed to try to pass a value back to the color, you can just use the return statement. In this case, we're using it not only to break out of the loop, but to break out of the method itself. So if there was any additional code here before we reach the end of the method, it wouldn't execute. The yield statement in C# is interesting. You can use yield in conjunction with the return statement to build a collection. So typically, if I have a method that we need to return a collection of integers, for example, I need to allocate a new array or a new list and completely populate that array or that list with all of the integer values that I need. What yield return allows you to do is build up a collection in a lazy manner and expose it through an IEnumerable interface and the values you produce with the yield return are consumed on as needed basis. In this case, someone could write a foreach loop to loop through everything that we return from compute ages, and we'll be returning a 2 and a 21 and then the values between 22 and less than 32. That's taken care of by this yield return keyword. Let's jump in to the demo applications to take a closer look at yield return. Here's a method called GenerateSomeNumbers that is using yield return to build an IEnumerable collection then a calling method is going to enumerate using foreach. I'm going to run this in the debugger so we can step to the statements and see how this behaves. So right now, I'm on the initializer of my for loop and I'm going to start pressing F10 to do a step over and you can see I've reached the yield return point where I'm going to return the first value which is zero. Now, at this point, I'm going to press F11 to make sure I step in to any method calls as they happen, but I'm about to write out that zero, and something magical happens when I come back for the next value inside of this foreach loop. All of a sudden, I've jumped back down into Generate Number, so this little yellow arrow essentially represents the instruction pointer of what's going to execute next. If I press F11, now I'm ready to yield return the value 1, that comes back into my foreach or right up the 1. We go to the foreach and ask for the next value and you can see I'm in GenerateSomeNumbers again. So I'm only producing numbers as they're being requested by the move next method of the enumerator that the foreach is using. In computer science, this is known as a continuation because even though we're yielding control out of these methods so that the color can execute and do some work, the program seems to know exactly where we left off here and later when we need to, we could continue executing inside of this method where we left off. Continuations can be quite useful, for instance, suppose instead of just using a loop to produce the numbers that we need, we're actually doing something that's very computationally expensive, maybe we're making a web service call or performing a lot of mathematical operations to produce each number. In that case, it's unfortunate to make the caller wait for the entire list of numbers to be produced, in fact, we could write something that would set up an infinite series of numbers here. And that will be okay as long as the foreach stopped iteration at some point. So you can imagine if n equals 10, we'll use that break statement that we talked about to break out of the execution of the foreach, and that would be fine if this was producing an infinite series of numbers. And even it's computationally expensive, if there's a chance that the foreach loop might not try to iterate through every value because there's a break statement somewhere, then by using yield return, it means we've done the least amount of work possible. We've only produced the values that are actually going to be , you effectively terminate the iterator. So you notice that the C# compiler at this point says that there's unreachable code detected. That's because yield break would effectively be the end of the IEnumerable and the end of the values that we're producing, the foreach would have nothing to iterate over and this statement, we'd never continue execution into here to return the 200. We'll talk a little bit more about yield return when we get to language integrated query later in this course.
Throwing Exceptions
The throw keyword in C# is used to raise an exception. An exception is a signal to the application, it also do the common language runtime that an error condition exist. As the name would imply, an exception should only be raised in an exceptional circumstance, that is, you shouldn't use exceptions to change the normal program flow. It tell you when you get in a condition where you haven't maybe an input value that you do not know how to handle or you have some constraints that you cannot work under like a low memory condition. Those are the types of situations that require exceptions. We'll see that exceptions are type safe because every exception object is going to be of a specific type and you'll have the compiler's assistance in handling errors. We also say that it is structured error handling because we can set up a control structure that includes blocks of code and exception filters to catch very specific errors. We'll be looking at how to do that in just a couple of slides. For now, just know that when you throw a new exception, the runtime is going to start looking for a handler that is advertising that it can handle that type of exception. In most programs, this means that runtime is going to begin unwinding the stack that is literally undoing all the colors that have gotten you to this point in the flow of the program. And ultimately, if there's no one available to handle that exception, it could result in the application being terminated. In this code snippet, we're checking if the age variable is equal to 21, if it is, we'll throw a new argument exception so you can see that an exception object will have a type definition, in this case, argument exception so we need to create a new instance of that class and we can pass in a description that will give some additional information about this error. Now if it is a common occurrence that age should be equal to 21, it's probably not something that you actually want to generate an exception for. Exceptions should be for the exceptional circumstances. Inside of the demo project, we have a console mode program and in the main entry point, we're going to invoke a method DoWork, that's the first thing we do. And the DoWork method invokes another method called DoSomeMoreWork. And inside of DoSomeMoreWork, we're going to raise an error condition, we're going to throw a new NotImplementedException. That's the exception that you want to raise when you have a method defined but you haven't provided an implementation yet. You'll notice that we also have some Console.WriteLines sprinkled throughout the program, but let's see what happens when we run this program. You'll notice that the Visual Studio Just-In-Time Debugger pops up because we have an unhandled exception. Essentially, the application is terminating but the debugger is going to step in and gives us a chance to debug this thing. I'm going to select no and you'll notice that we didn't get any output from Control Flow at all. And that's because before we got to any of the Console.WriteLines, we had this NotImplementedException, and it traveled up the stack through DoWork and through Main. It never found anything that was capable of handling this type of error, so the program terminated. If you notice the little green squiggle here, that's a compiler warning. The C# compiler is smart enough to figure out that this code is unreachable and because we're throwing the exception here, the execution of the program will never reach this line. Now this behavior terminating the program, because there was no exceptional handler for this error really depends on the type of application that you're building. I'm going to switch to another project which is an ASP.NET project, just the standard project that come when you do file new ASP.NET website, and I'm going to run that application. You could see that everything is behaving normally. We get a Welcome to ASP.NET page, and I should point out that this ASP.NET website is running under the little web server that comes with Visual Studio, the ASP.NET Development Server. Now let's go back into the website and inside of the page load event, I'm going to throw a new NotImplementedException, save this file and let's refresh the page. And now we see the ASP.NET is displaying in error. The method or operation is not implemented, an unhandled exception occurred but our Web Development Server never stopped executing. So this exception even though it was unhandled, didn't terminate the web server process. And that type of behavior is particular to ASP.NET because ASP.NET doesn't want an unhandled exception in your code to terminate the entire Web Server that might be handling request for multiple users. So ultimately, ASP.NET is going to catch any errors-- any exceptions at arrays inside of your code or code inside of the framework that your code is calling to prevent the entire web server from being torn down. And when you're debugging, it's going to print out all sorts of the information about that exception including where it occurred and a stack trace that shows the methods that were called leading up to the exception being thrown.
Built-in Exceptions
There are quite a few exception types already built into the .NET framework. These exceptions are available for you to throw as well as to handle. All of the exceptions derived ultimately from the System.Exception base class and when we talk about creating a custom exception, we'll see that you'll also have to derive from the System.Exception base class. In fact, the C# compiler will not let you throw an exception that doesn't ultimately derive from that base class. But here, some of the exceptions that are in the .NET framework, there's a DivideByZero exception if you try to divide by the value zero. The IndexOutOfRange exception if you try to index into an array using an index value that's outside the bounds so that could include like a negative index value. The InvalidCastException, we talked about casting a few modules ago that could be when you're trying to coerce an object into an integer but it turns out that object was actually a string, it would throw an invalid cast exception. NullReferenceExceptions are quite popular. If you have an object to reference that hasn't been initialized that set to null and you try to dereference that object to invoke some method or touch some property, you'll get the NullReferenceException. A StackOverFlowException actually is something that you cannot throw yourself or even handle, but I do point it out because you occasionally see it. I'll show you why in the demo project. That's a common error that sometimes occurs in C#. And another type of exception to watch out for is the TypeInitializationException. This one is unique because it occurs when there's an exception inside of a static constructor or somewhere inside of the code that a static constructor is invoking and there's no one available to handle that error. And the original exception could be of any type. It could be a simple NullReferenceException, but it's going to be transformed into a TypeInitializationException because that type is not initialized. So now, anytime you touch one of the static members of that type, you'll see a TypeInitializationException. Here in the demo project, let's see if you can spot the bug. We have a public class called Employee, has a private field underscore name. We're going to expose that name through a public property, that when someone tries to do a get, we'll just return the name. Inside of Name, we'll construct a new instance of Employee and try to get the Name property. Let's run the program and we'll get the unhandled exception just in time, debugger popping out to debug the program. If we look at the output, we can see that the process is terminated due to a stack overflow exception. So what was the bug? The bug was that when someone invokes the name property to get the Name, we're trying to return the value of the Name property, so we're invoking name again. And that's going to call back into Name, you can see how this becomes an infinite loop of trying to get the Name, eventually, because behind the scenes, properties in the CLR are just method calls. Eventually, we're going to run out of stacks base as the runtime keeps allocating a piece of the stack for that method call to work on. The fix, of course, is that what we actually wanted to do was return the backing field which was underscore name. So I've occasionally done this by accident, that a reason I point it out, and that's probably one reason why you get a StackOverflowException. If you want to browse other exception types that are defined by Microsoft in the Base Class Library, then I recommend downloading a tool called .NET Reflector. This is a free tool that is an excellent tool for browsing assemblies and the types inside these assemblies and even decompiling the code that is inside of these types. This is available from redgate.com and I should point out that there a couple of Pluralsight how-to videos on using Reflector. If I just want to find types that are related to system.exception, I can open up Reflector, it's going to have a have a certain set of assemblies loaded for me already. I'm going to do a view search and search for system.exception that found the exception class and what I'll do is I open this up and we can get a list of all the types that derive from system.exception. So I can look at this. And there's quite a few but it turns out many of the exceptions that we're interested in that will come from .NET are nested under the system.exception type. So they're derived from that base type actually. So it's inside of here where you will find argument exceptions, so you pass the method and argument that it didn't expect, maybe a null pointer or an arithmetic exception, and you can see there are several types derived from this exception class including the DivideByZeroException or the OverflowException. There are a number of IOExceptions, for instance, DirectoryNotFound, FileNotFound or DriveNotFound, and it's inside of here where you'll find things like the OutOfMemoryException. So using Reflector, you can find all o the exceptions that are defined in third party libraries and libraries provided by Microsoft.
Handling Exceptions
In a C# application, you do have the option of trying to handle an exception and you do this using a try block. A try block is the try keyword followed by some curly braces and inside the curly braces is the code that you want to execute that might throw an exception. The try block can be followed up by zero or more catch statements. In this case, we have a one catch statement. We'll talk about the case of having zero or more than one in just a bit. When an exception is thrown, say, inside of CheckAges, the runtime is going to look for the closest matching catch statement. By matching, I mean that if CheckAges were to throw a FileNotFoundException, this catch statement would not catch that exception because it is trying to catch exceptions that are DivideByZeroExceptions so we can catch this exception type or exception objects that are derived from this type. A FileNotFoundException is not derived from the DivideByZeroException. By closest, I mean that the runtime is going to look for the closest handler that matches that the one that is nearest to the point where the exception occurred. So that the exception occurred inside of CheckAges and there were no other exception handlers inside of there that would catch DividedByZeroExceptions, then this catch statement would get the opportunity to catch that error. If this code was inside of a method that higher up the call the stacks, some other method was invoking this and also had a catch statement and after a try block that was trying catch DividedByZeroExceptions, our handler would get to catch the exception coming out of CheckAges because we are the closest and we have a match here for the right type. In the demo application, let's return to the DoWork method and remember that DoWork invoked DoSomeMoreWork and DoSomeMoreWork is throwing a NotImplementedException. First, let's see what happens if we put a try catch around DoSomeMoreWork, and we try to catch an ArgumentException, and notice that if I do not need to do anything with the exception object itself, I don't have to specify a name for the exception object that we catch. That would just produce a compiler warning that variable ex is declared but never used. I'm going to take that off, let's build this program and run it, and you'll see that we still have a problem. The process still terminates because DoSomeMoreWork is throwing a NotImplementedException. That's not related to ArgumentException, it's not derived from that at all. So this catch statement didn't catch the error that was coming out of DoSomeMoreWork. If instead, we are actually trying to catch the NotImplementedException, then what would happen if I build this and run it again, this will actually executes the program. Essentially, what we did was catch the error and allow the program to continue executing. So we swallowed that error which is a problem in and of itself. If you catch an error, which truly represents some exceptional circumstance that happened somewhere else in the program, you don't know if maybe the program was corrupted or if you're going to save something that's in a bad state now. So you have to be very careful when you do this. So you can see now how the runtime looks for something that has to match. Also, if I did a catch, just a base exception here, system.exception, that's go into capture pretty much everything that comes out of DoSomeWork. There's only a few exception types that will not be caught by catching system.exception, and that includes the StackOverflowException that we looked up before because once a stack is overflowing, there's pretty much nothing you can do at that point, something's terribly wrong in the program. Now let's go up into the main method that's calling DoWork and let's have a try catch block here. So I'm going to try calling DoWork and putting a catch block that will just catch Exception. But actually let's go ahead and catch NotImplementedException, and what we'll do is we will WriteLine that we Caught a NotImplementedException in Main, and let's also copy that code and put it down here. I mean, of course, here, I'll say that we caught it inside of DoWork. Let's compile that program and run it once again and observe what happens. You'll see when the program begins executing, we caught the NotImplementedException in DoWork that we did some work and then we continue the execution. So when the exception was thrown inside of DoSomeMoreWork, we handled it here with this catch statement. Up in Main, even though we had a try catching in place, this catch Not statement never saw error and was already handled at a lower level. Now let's come back here and put in argument exception, we've already demonstrated that this doesn't catch the NotImplementedException thrown by DoSomeMoreWork. But just for kicks, let's run the program and look at the output and it should be as you expect, which is that we caught the NotImplementedException in Main and then continue the execution. Once you have caught an exception, you can get some information from the exception object. In this case, I'm going to go ahead and give a variable name for my exception object, that's going to be ex, and now I can paste in some code that will rate out some properties that are on that exception. So just the Message, a StackTrace and the TargetSite. But to run the application, and take a look at the output, you can see that we caught a NotImplementedException in Main. The message is that the method or operation is not implemented, and then I have a StackTrace that actually pinpoints the line of code where this exception occurred and then the last piece of information you can see here is the TargetSite which was the method that returned void, and has the name DoSomeMoreWork. This is the type of information that we want to dig into if you're logging errors that happen inside your application or when you're debugging exceptions that happened inside of an application and you're trying to find out the line of code that created that exception.
Chaining Catch Blocks
After the try block, you can follow up with multiple catch statements. This is known as chaining the catch statements, and even though we have multiple catch statements, only one of these catch blocks can execute after an exception is thrown from inside of the try block. The catch blocks will be evaluated from top to bottom and the first one that specifies the exact type of the exception or a base class of the exception that has been thrown gets the chance to execute. This is why when you chain catch blocks like this, you want to include the most specific or most derived type first. So DivideByZeroException is a more specific type than the base system.exception class which would catch everything and again that can be dangerous unless you'll going to rethrow the exception which we'll talk about in just a bit. If we were to reverse these two catch statements and put the catch exception first then this is the only block that would ever execute. The DivideByZeroException catch block would never get a chance to execute because this one would catch every exception that's being thrown, if it appeared first.
Finally
After a try statement, you can optionally include a finally statement. The finally statement allows you to specify a block of code that is always going to execute even if there's an exception thrown inside of the try block, and even if that exception is not handled by any catch statements that you have here. These makes the finally block a good place to add finalization code, that is, clean up resources that you might have acquired like a FileStream or graphics handle or a database connection. In this sample, we're opening a file on disk, we want to ensure it's closed to even there's an exception that is thrown. We can do that with a try finally in putting the file.Close in here. And although I didn't show it in this example, you can have one or more catch statements in here that tried to catch exceptions. You might remember in our previous discussion on types, we talked about the IDisposable interface. This is another way to clean up resources and that's done with the using statement. You can stack this using statement so that you can, in this example, open multiple files and ensure that both file1 and file2 will be properly disposed or closed even if an exception happens inside of this using block that escapes and goes unhandled. So you might be wondering which approach is best. Should I be using a try finally to clean up resources or should I use the using statement to clean up resources? I intend to use the using statement wherever possible because I think it makes the code easier to read, but remember using only works when this type implements the IDisposable interface. If you need to make sure that you execute some other code that might not be related to IDisposable, that's when you can fall back and use a try finally.
Re-throwing Exceptions
There are times an application development when you will want to catch an exception and then re-throw that exception or perhaps catch an exception and rethrow a different exception. We're going to talk about some of those scenarios. First, let's talk about rethrowing the original exception. This is quite common in logging scenarios. So we're going to catch an exception and we're not going to try to fix the problem, we just want to record some information about the exception. That code might look like this. We're going to try some operation and then we'll catch system.exception, we'll catch every possible error. As I said before, this is generally considered a bad practice because you don't know all the different types of exceptions that might be coming out of this code. You typically just want to catch exceptions for things that you might be able to fix. For instance, in a desktop application, if the user gives you a file name, you can try some operations and see if you catch FileNotFound exception. In that scenario, you could prompt the user to give you a different file name because the one that they gave you wasn't correct. But again, in this scenario, we're not trying to fix the exception, we just want to log the information about that exception into the event log or into a SQL server database or perhaps send some information and page in the administrator so that they can come and fix something that's wrong about the software. And then we want to rethrow the original error so that error information can continue to propagate to the application and perhaps reach someone that can fix the problem or handle that error, or perhaps it will tear down the application because it really is in a bad state. To do this, you want to use the throw keyword without specifying an exception object, so it's just throw and a semicolon. We can do throw ex which really would be rethrowing this original object but when you do that, what happens is that the StackTrace will now be pointing to this location saying that exception originated here when in fact it originated somewhere inside of the try block. By doing just a throw and a semicolon, you preserve all that original information that's in the exception object. Now there are also cases where you want to catch exceptions and then hide them because you don't want them to escape, so the typical scenario here might be a web service where someone has invoked that web services and it finds out that it's low on this space or it cannot connect with database server. The person who's calling the web service doesn't need to know that information, in fact, it might be dangerous to give that sort of information out. Someone can use a database name or a server name as information that they can use to attack you. This is why you can go to website or call web services and you get back very general error messages like the server cannot respond to the request. What might be actually happening on the server is that it can't connect to a database or it cannot open a file that it needs to run, but it doesn't want to give you that information because you don't need to know it. So these types of scenarios, it's quite common to grab every error that you can, log as much information about it as you can and then just throw a new general exception with the message like we can't respond to this request. For business object sometimes, you don't want to hide that original exception but you do want to wrap it inside of a more meaningful exception, or an exception that has some meaning to the business. For instance, the block of code inside this try statement might throw a DivideByZeroException and we might know that because it did that, we have some invalid account information that the user entered or invalid account information that was stored in the database. So we're going to take that exception and wrap it inside of an InvalidAccountValueException. Every exception constructor allows you to pass any message as a string and also an inner exception that's going to be wrapped by this exception. Someone can already catch block for this specific custom exception that we've implemented and we'll talk about how to implement a custom exception like InvalidAccountValueException in just a bit. But if they do catch this exception, they can use the inner property to examine the original exception and see if StackTrace for where that came from.
Custom Exceptions
To create a custom exception like the one we are just looking at, you just need to follow a couple simple rules. First, implement a class and derive from a common base exception. That means you want to pick an exception that already exist for your base class. In some cases, you might just want to use system.exception. But let's say you're doing some mathematical operations inside of a complex number class, in that situation, you might pick the arithmetic exception as a base class. When you name the class, make sure you use an exception suffix on the class name, for instance, InvalidAccountException. This allows people to easily identify those as a class that's only going to be used for error handling. And it's generally considered the best practice to make the exception serializable. You can do that just by adding the serializable attribute and also providing a special constructor that uses some serialization information. All you need to do for this is just pass the information along to the base and everything should be taken care of for you. This is pretty much boilerplate code that you'd need for every exception and is actually very easy to create inside a Visual Studio. So here we are inside of a new.cs file called InvalidAccountValueException. What I'm going to do is delete the class definition that is already here and I'm going to right click on that Editor, I'm going to say Insert Snippet and then I'm going to click on the Visual C# folder, and inside of here, I will find a code snippet for exception. So I just need to highlight that and click on it and it's going to generate all the information that I need for the exception class including that serializable attribute, and only I need to do now is just type in the information that I need. So, and then tab through it and you can see as I change the name to InvalidAccountValueException, it updated all the code inside of here for the constructors to match that name.
Summary
In this module, we looked at all the flow control statements. These included the conditional branching statements like the if statement as well as the conditional operator also known as the ternary operator. We looked at looping statements like the for loop, the do while, the while, and the foreach, and also the jumping statements like break, continue, goto, and return. Finally, we took a close look at exceptions because exceptions are the error handling mechanism that is built in to .NET. And sooner or later, you're either going to create an exception and have to handle it, or you're going to reach a point where you need to start throwing your own exceptions. You can throw the built-in exception types that are already defined by .NET. We also showed you how to create a custom exception that you can throw.
C# and the CLR
Introduction
Hi, this is Scott Allen of Pluralsight. And in this module, we're going to look at C# and its relationship with the Common Language Runtime. In the first topic for this module, we will revisit the subject of just-in-time compilation and garbage collection. We'll also be looking at how you can interact with the threads of execution inside of your application. You'll need to do this if you want to have concurrently running tasks, or perhaps perform an asynchronous operation. We'll look at the Reflection API that's available in .NET, and see how we can take advantage of the metadata that is stored in our application. Reflection is an extremely useful feature of .NET. We'll also talk briefly about Processor architecture and how your C# application can run both on a 32 bit CPU and a 64 bit CPU. And we'll conclude the module by looking at how to achieve Interoperability with code that might be written for a different runtime, code that's written in C++ or Visual Basic. And we'll see how they can interop with code that is unmanaged and packaged into a dll or a COM component.
Garbage Collection
C# and the common language runtime are tightly intertwined. And one example of this relationship is how garbage collection works. We know that in C# we can construct a new object whenever we need one. Just using the new operator, we can bring an object to life. And we never have to worry about managing the lifetime of that object. The runtime has enough information to determine when we're no longer using an object, and it can free up the space of that object when (inaudible) the heap. The garbage collector does this by periodically running and visiting all of the static global variables that are available in our program, and also visiting all of the local variables that are on stack frames inside each of the threads that are running inside our program. And while it's doing that, it'll find and say, for example, a variable named employee, that's referencing an employee object on the heap. And it also knows that this employee object has a string property that's referencing another object on the heap. So it knows that these two blocks are being used, but it can mark these two blocks as being free and open, it didn't find any references to those areas anymore. They might be variables that have gone out of scope. The C# compiler provides enough information about the data structures that you're using, but the garbage collector knows the exact size of all these objects, and it knows what other references they may hold. So this is a relatively straightforward job to determine what's in use or what's not in use. That's not to say it's exactly easy because this has to be very performant, and Microsoft has worked very hard to make the garbage collector run extremely fast. Now, when the garbage collector finds these unused spaces, it's able to free this up, but it does one additional step. It also does what we call a compaction of the heap. So these blocks that might be sitting between two allocated objects can be condensed so that we have larger blocks of free space available. This keeps the heap healthy and it's very similar to defragmenting a hard drive. Compacting the heap is very much an optimization that can help our programs run faster, for example, by getting more cache hits. So as the garbage collector is moving objects around, it also needs to fix up references. So the employee name property that was formerly referencing a string that was in on side of the heap, that reference has to be fixed up by the garbage collector so that it's referencing the proper object. But we don't have to worry about any of this. It all happens behind the scenes, and it's one of the beauties of running managed code. We can just focus on solving some business problem and letting the garbage collector take care of all these memory concerns. At some point, we may no longer need this employee object. It will go out of scope. There'll no longer be a reference to that object on the heap. And the garbage collector can come along and free up everything that was associated with that variable. I want to demonstrate some garbage collector features using a simple console mode application. This application sets up a loop to create 100,000 employee objects. And we're not going to save a reference to these employee objects. We're simply going to instantiate them. And they're immediately going to be garbage on the heap because no one has a reference to these objects. And they're very small objects. They just have string property to store each employee's name. And as employee's name will simply generate like a serial number. We'll just assign the value of i to each name. At every 10,000 times through this iteration, we're going to write out the total number of garbage collections that have taken place. And I'll show you how to do that in just a minute. But let's go ahead and build this program, and then come out to the command prompt to run it. And you can see, right now, we get about halfway through our loop, just over 50,000 objects created before the garbage collector kicks in and cleans up the heap a bit. But let's try something different. Let's come back to our program, and make our employee object larger. So what I'm going to add here is a byte array that reserves enough space to store 60,000 bytes. Each employee that we create will require considerably more space on the heap. And now, let's do another build, and run our program again. And you can see, we still execute pretty fast, but this time, we've had over 2,500 collections that have taken place. So the garbage collector didn't significantly inhibit our performance, and yet, it's helping us out tremendously. Right now, we're not storing a reference to any of these employee objects, but I happen to have a list around, and instead of just creating garbage, let's actually store a reference to each employee object as we create it. And compile this program, and run it again to see how it behaves. ( Pause ) And you can see we got through about 30 to 40,000 iterations before we have an out of memory exception. We filled up the heap of so many byte arrays and employee objects that it simply ran out of space, and the runtime couldn't allocate anymore memory. And I should point out that I'm running in a 32 bit process at a 32 bit operating system, and it's a little bit easier to exhaust memory in this situation. Let's come back to the program and look at how we were calculating the total number of collections. We're using a class called GC, which is short for garbage collector, and that exposes a number of static methods and static properties that you can use to interact with the garbage collector. But you do need to be careful because some APIs, like the Collect method, which tells the garbage collector to go out and do a collection, can sometimes be detrimental to your program. Sometimes, it's best to let the runtime and the garbage collector work together to figure out when the best time is to run a collection instead of you forcing its hand. The methods we're using here, CollectionCount, will ask the garbage collector, how many collections ran in a specific generation? So in the regular managed heap, there are three generations of objects. When we first create an object, they get placed in Generation 0. And if they survive a garbage collection, that is, they're still referenced when the garbage collector runs, they'll get promoted to Generation 1. And if they survive a collection there, they'll get promoted to Generation 2. This is an optimization of the garbage collector uses because most applications have a tremendous number of short-lived objects. We create some objects that are only used inside of a single method column that we don't need them anymore. Those types of objects will live in Generation 0, which typically gets collected more frequently than Generation 1 and 2, because Generation 1 and 2, they're holding objects that have already lived through a collection and they might be sticking around for a while.
Threads
When we talked about the garbage collector, we talked about the garbage collector going out and looking at the stack frames and all the threads that were executing in our application, define those variables that were referencing objects to understand what we were still using and needed on the heap versus what it could clean up as part of a garbage collection process. So we know the garbage collector interacts with threads, how about our C# application? Yes, there's often times when you want to use threads. You might want to do some concurrent programming. You might want to set up something to do in asynchronous operation. For instance, you might want to call a web service, but while you're waiting for that web service to return which might be five seconds or 20 seconds, you want to be able to keep the screen updated and respond to user clicks. So you perform that operation on a background thread and you get notified when the web service returns, you can get the results and present them to the user. The threading APIs that are available to a C# application are varied. As the last ten years have elapsed, we found better ways to manage concurrency and interact with threads from an application. But there are essentially two APIs. There's some classes available in the System.Threading namespace, and these are low level APIs that allow you to explicitly start a thread, tell it what to execute, you can tell that thread to stop, or you can join that thread and wait for it to finish executing whatever piece of code you gave it. .NET 4.0 introduced System.Threading.Tasks. The API available here is a much higher level API that abstracts you away from manipulating individual threads, instead you simply describe to the runtime the different pieces of work that you need done, and that takes care of managing concurrency and aggregating exceptions across all those different threads to report back to you what happened. The idea is to keep developers more productive by abstracting away some of the low level threading details. Here's an example. Let's say we wanted to download the content of the homepage for Pluralsight.com, microsoft.com, and odetocode.com, we could go out and instantiate a web client and use the download string method to pull down that content and do that one after another. But if this takes one second and one second and one second, that'll take three seconds to complete. An alternative would be to spin up a thread for each task, which if you're using the System.Threading API, requires a lot of low level programming and doing things like new thread and Thread.Start. With the Task Parallel Library, there's a class available called Parallel that has a number of static methods that allow you to easily set up some concurrent tasks. So what this code is doing is setting up a ForEach loop that will look at each one of these items and try to process them concurrently. So if each download takes one second, we might get the results back in just one second. And it's very easy to express this intent using Prallel.ForEach.
Threading Demo
I want to demonstrate some of the code we had on that last slide, so let's come in to Visual Studio where I have three websites set up, Pluralsight, Microsoft, and Twitter, and we're going to use the web client to download content from each of these websites synchronously. So we'll simply loop through each URL that's available in the string. We'll invoke DownloadString. And when it's complete, we'll print out the number of characters that we got back from the website as well as the ID of the managed thread that's being used to perform this work. This method is being invoked from the Main method in our console mode application, and this method is also going to print out its ManagedThreadId that's going to do that after a control returns from DownloadSynchronously, and then will simply wait for me to press a key before exiting the program. So jumping up a console prompt and start this program running. We're back after about ten seconds have elapsed and the program finally finished downloading content from all three websites. You can see that it pulled down about 90,000 characters from microsoft.com. Notice that these operations perform in the order that they appeared and the array of strings that we had for URLs, and that all of these completed on thread ID 1, including our main thread which had to wait for all these operations to complete before it could continue on. Let's come back into the program and see if we can speed this up by using multiple threads. So the first thing I'm going to do is I'm going to create a new method called Download that just takes an object parameter. And I'll explain why we have an object parameter in just a minute. But I'll take the code that's inside of this ForEach loop and paste it into here. The one slight change we have to make is that we have to do a ToString operation on the URL since it's coming in as an object parameter. And now, what we'll do is we'll use separate threads to perform each download. So I already have a using statement per System.Threading at the top of this program and I'm going to construct a new instance of a Thread class, and I have to point it to a method that's going to be invoked when this thread actually executes. So the code inside of Download is what this thread is responsible for executing. Now, once I have a reference to a thread, there are several things I can do with it including telling it to start. And when I tell it to start, I can pass in a parameter which is going to be the URL that needs to be downloaded. Now, since the threading API doesn't know what kind of parameters we need to pass around, it's just going to force this parameter type to be of type object, and that's why we have to do a little bit of manipulation to get that into a string that the Download string method expects. So here, we've seen a couple of ways to interact with the threads that are actually executing instructions inside of our application. There are some static members of the Thread class that you can use. Thread.CurrentThread, for example, will give us a reference to the thread that we're currently executing on. And once we have a reference to a thread, we can look at its priority, we can give it a name, we can see if it's a background thread. There's also some operations that you can perform that are static members of the Thread class in addition to getting a reference of the current thread. There's also some helpers in here to do things like tell the thread to sleep for so many milliseconds. But we don't need this in our program, so I'm going to remove that, and then I'm going to rename this method to download asynchronously, because that's what we're really going to do now. And now, let's build the program and run this version from the command line. Now, our program finished executing and it took about half the amount of time that we were taking before when we were using a single thread, and there's couple of things I want to point out. First of all, "Waiting to finish on thread 1" appeared first. And that's because when we invoked DownloadAsynchronously, we spun up three new threads that actually did the work, and the main thread that's executing inside of our console application was free to return from DownloadAsynchronously and come out here to do this Console.WriteLine. So that finished almost immediately. The other thing to notice is that the websites came back in a different order. So Twitter was the first to respond, and we pulled down almost 50,000 characters from Twitter. And the work for Twitter was performed on thread 5, for Microsoft on thread 4, and for Pluralsight on thread 3. So we can see at least four different managed thread IDs in play here, and we were able to speed up the program. However, working at this low level with a thread API isn't always the best approach to asynchronous operations. Let me show you a different approach.
Async Demo
Now, I mentioned that the ways to achieve asynchronous programming and concurrent programming using threads are varied in the .NET Framework and that every few years we seem to discover a new mechanism to perform asynchronous work. So this time, let me invoke download directly, and now we can pass in the URL as a string. And what I want to show you is that there are classes in the .NET Framework that revolve around network access and other things that might be a little bit slow that provide built-in asynchronous operations. Windows Communication Foundation Service Proxies will include these asynchronous operations if you include the option to generate them, and the web client class does as well. So what I'm going to do is I'm going to take this code that we have here and I'm going to paste it and comment it out because we'll want to come back to this a little bit later. And for now, I want to show you that there is an asynchronous version of all these download methods. So there's DownloadString and there's DownloadStringAsync which automatically performs the work on a background thread for you. You never have to explicitly spin up a thread or say Thread.Start. And in many ways, this is going to be the preferred approach, because DownloadStringAsync can use threads from the Thread pool. Threads can be relatively expensive to create. So the .NET Framework maintains a pool of threads that are available to do work. And once they complete a job, they remain in the pool until the next piece of work comes along. These Async versions of the methods will use those Thread pool threads. So we're going to invoke DownloadStringAsync, and just as before, we need to pass in a URL, but notice the return type of this method is now void. We don't get a result back instantly. Instead, what we need to do is hook up an event that will fire DownloadStringCompleted, and this event will fire when the web client has finished downloading or when it encounters an error. And it's inside of this EvenHandler where we can harvest the result of the download. So let me take out the thrown NotImplementedException, and we'll also take out the DownloadString method called that's here, and we need to take our Console.WriteLine that's going to print out information about the result and put it inside of our EventHandler. The html that used to be returned from DownloadString will now be available through the event arguments that are a parameter to this method. And I can save our html equals e.Result. And you can see, that's typed as type string. Notice, we also have this URL. So how can we know what URL we were operating on when this event fires? Well, the answer is that most of these asynchronous functions provide a way to tunnel some additional information along inside something called a userToken. So I'm going to tunnel that URL along inside the userToken, and we also need to make this a formal URI parameter. So we're going to take the URL and pass it into the URI constructor. And down here in, my EventHandler, I should be able to get to the URL by looking at this UserState property which is of type object because the .NET Framework doesn't know what kind of state you need to pass around, but we'll just coerce that into a string, we know it's going to be a string. And so, now, I'll just clean up the code a little bit so it's a little more readable. We don't actually need this DownloadStringCompletedEventHandler type name here. The C# compiler can figure it out. And now, what we have is a slightly more efficient and still asynchronous version of the code. It's going to be using Thread pool thread, so we didn't need to explicitly create any threads of ourselves. So now, we should be able to do a build and run this program once again. Now, the program is complete and we have roughly the same results as before. What's interesting is that the Pluralsight website and the microsoft.com website both executed on the same thread. That tells me that one of these websites was so quick to return the information that we didn't need to create three threads to download information from three websites. We were able to do it with just two threads very efficiently. And notice that the main thread, thread 1 inside our console mode application, was still the first one to reach that point where it's able to say I'm just waiting on everything else to finish. So these asynchronous versions are great, but we really lose the intent of the code here. We've taken an operation of let's just download information from three websites. And because we wanted to perform that asynchronously, we've had to split our code across three different methods here. This is where the System.Threading.Tasks namespace comes into play and the Task Parallel Library.
Parallel Demo
So let's rewrite our ForEach loop using Parallel. Parallel, again, is in System.Threading.Tasks. It exposes a few static methods. For instance, the Invoke method, you can just pass it essentially an array of things that you want invoked asynchronously, or you can use the ForEach. What we do is point the ForEach method at a collection, like this collection of URLs, and then we give it an expression to tell the Task Parallel Library what action it should perform asynchronously or concurrently. And in this case, I'm going to use a lambda expression. If you haven't seen a lambda expression before, we go into great detail about what lambda expressions are in the second module of the LINQ course. But essentially, a lambda expression is like a small method, a small anonymous method. And the code that I want inside of this method is going to be the code that we were using before to download synchronously. So I'm going to uncomment that and paste it into this expression. And now, what we have is a little more readable. When we look at this download method, we see that there's a web client, we're going to download a string. When we get the result, we're going to write out the number of characters that we pulled back. And we can see we're going to perform this action for each URL that's in this collection of URLs. And we'll do that in a Parallel manner. So the Task Parallel Library is very good at expressing intent without getting caught up in all the details and machinery of actually working with threads and async operations. Let's do a build and come out to our command prompt to run this program again. And the program is, once again, complete. It took about the same amount of time as our last asynchronous version. There was no difference in execution speed. But notice that our main thread, that thread 1 that's in the console mode program, was blocked and waiting for this Parallel activity to take place. So one thing about Parallel about ForEeach is we're asking the Task Parallel Library to go out and complete each of these actions, download content from these three websites, but let's not leave this method or proceed onward until all of those complete. So thread 1 was left waiting for everything to complete. And in fact, thread 1 was actually used to download content from Pluralsight-training.net. We also use thread 4 and thread 3 for a total of three threads. So again, very efficient utilization of threads combined with very expressive code.
Reflection
Another feature of the CLR that you can take advantage from in C# is the ability to do reflection. This is a code reflecting upon itself, like looking in a mirror, it can examine itself. Most of the Reflection APIs generally start by first giving a reference to a System.Type object. And you can do this either using the GetType method that's available on any object, or using the type of operator if you know the type that you need ahead of time, at compiled time. And once you have this type reference, you can start to make queries against the metadata that the CLR holds about a type. And this metadata includes information like the properties that are available on any given object of that type. In this sample code, we're invoking GetProperties, and that gives us back an array of PropertyInfo objects. We can walk up to each one of those PropertyInfo objects and find out what a given property's name is or what its type is. Here in Visual Studio, we're looking at a simple program that's going to use Reflection on type of program, which is this class that holds our Main method which is the entry point for this console application. Once we have a reference of that type, we're going to invoke GetMembers. So the code on the slide was using GetProperties which should give us back just the properties on the type, GetMembers should give us everything. So this will give us methods and this will give us properties and events, and so forth. Let's run this program and see what we get back. You can see we have ToString equals GetHashCode and GetType. Those are the four member infos that we found on this type. And you might say, but wait a second, what about this Main method that's a static method? But why isn't that showing up in the list of members for this type? By default, most of this Reflection APIs that do a Get on information like GetMembers or GetProperties, they're going to return just public instance members by default. However, it does an overloaded version of this method that allows you to pass in BindingFlags, and this BindingFlags allow you to describe exactly what you're looking for. BindingFlags are an enumeration that you can ore (phonetic) together. And what we're saying is here is that we want Static members and Instance members, and we want both NonPublic members and Public members. So the BindingFlags in place, let's build the program and run it again. And you'll see, we get additional information. There's the Main method, and we also see methods like MemberwiseClone and Finalize. Both Finalize and MemberwiseClone are protected numbers of System.Object.
Attributes
Another use case for Reflection is the ability to look at attributes on a type or on the members of a type. For example, here is an Animal class, and every animal has a name. This name is decorated with an attribute, the Required attribute. This attribute comes from System.ComponentModel.DataAnnotations, and these types of attributes are quite popular in ASP.NET MVC applications, because it tells the runtime additional information about this property of animal. For example, if you build a view where the user has to enter information about an animal and they do not enter a value for the name property, the MVC Framework can automatically tell the user that there is a problem. That they didn't fill up the name property and that it is required. So these attributes are baked into the assembly by the compiler, and they're associated with types and members and methods and properties. And at runtime, you can write code or the framework has code to look at these attributes and perform different behavior based on what this attribute is describing. The snippet of code down here is code that is going to look at the Animal type that's going to get property information about the property Name, and then we're going to use the GetCustomAttributes method of that property info object to retrieve all the attributes that have been attached to that Name property. We'll loop through those and write out the name of each attribute. Let me show you how this program behaves when we run it. And you can see that we get the RequiredAttribute. That's the only attribute on that property. So you can see it's relatively simple to walk up a type and look at these attributes. And attributes in the .NET Framework can control everything from user input validation to database transactions. In fact, you might find attributes so useful that you want to create some of your own.
Custom Attributes
Custom metadata is metadata that you can define by creating a class derived from the built-in System.Attribute type. What you're defining as a custom attribute, and you can give this any sort of name, but the convention is to end the class name with the word Attribute. And you can define where this attribute can be applied by using a built-in attribute, the AttributeUsage attribute. You can say that this DangerZoneAttribute can target a property only. You can also use this enumeration to target interfaces, methods, parameters, classes, assembly level. You can ore these together so that you can apply an attribute on classes and properties, for example. To use this attribute, once you've defined it, you can specify just DangerZone. The attribute part of this is optional when you actually apply one of this custom attributes. An attribute can have a constructor. In this case, we need a minimum value and a maximum value. Those would be required when someone applies this attribute. And you can also define additional properties here that are going to be set by using names when the attribute is applied. I'll show you that in just a second. Once the attribute is defined and is in place, you can use that Reflection API that we just saw in the last demo to go up and then see if any given property has this attribute in place. Here in Visual Studio, we're looking at the DangerZoneAttribute, and we can see it applied to the Age property on the Human class. And there's one difference between this class and the class we had on the slide, and that's the presence of a Message property. It turns out that when you're applying an attribute, you are forced to pass parameters for any constructor that you might be using to apply this DangerZoneAttribute. And in this case, we only have one constructor defined. It requires a minimum value and a maximum value. So we're forced to pass those in. But this is slightly different than invoking a method, a slightly different syntax, because what we can do in here is set any public property of that attribute by specifying its name. So for instance, we can specify the value that the Message property should hold when we're applying this attribute just by saying Message equals and then some string value. I also want to point out that this attribute is defined such that we can only use it on a property. So, if I were to take this attribute and try to apply it at the class level, we'll have a compiler error when we do a build that this attribute is valid only on property declarations. If I wanted to make this attribute available for both properties and at the class level, I could ore these attributes together. So now, we can apply this attribute at the class level or the property level. And you can see there's a number of different options in here for exactly what you want to reach with this attribute. With the Reflection API, you cannot only inspect metadata, but you could also can invoke methods and get and set property values. For example, in this first code snippet, we're getting the type of some arbitrary object, and then getting a reference to a PropertyInfo using the GetProperty method and passing in Length as a string. So we're looking for the PropertyInfo for the Length property. We can then get a value from that property by invoking the GetValue method and passing in the object that we want this operation performed on. And GetValue doesn't know what type of value you're going to get out of this, so it's simply returned an object reference. If you expect a more specific type, like an integer, you have to do a typecast. The second parameter, by the way, to get values is only useful if you need to pass parameters into GetValue. And that would be the case if you were invoking an indexer property. In this case, we expect Length to just return an integer and a sudden indexer, so we just pass in a null reference there. We can also walk up to some object and invoke GetMethod to get a MethodInfo reference. In this case, we're going to get a MethodInfo reference to the Compute method on this object. At that point, we can then invoke that method. And if the method takes any parameters, we can pass those in by packaging them into an object array. It looks like we expect the Compute method to take two integer parameters, so we'll pass in a 2 and a 5, and we expect to get an integer result out of this. So again, we'll need to typecast it. If you're using C# 4.0, you can use the dynamic keyword. The dynamic keyword essentially bypasses any static type checking that the compiler typically will do. And this means we can walk up to any object and do a .Length. And at runtime, not compiled time, at runtime, the runtime will try to find that length property and retrieve a value from it, and coerce it into an integer for us. And in fact, it's the same behavior we had here, only the code is a lot cleaner. And both pieces of code run the chance of having a runtime error if that length property doesn't actually exist, or the value it returned is not actually an integer value. The dynamic keyword, by the way, was introduced into C# 4.0 to achieve interoperability with COM and also dynamic languages like IronRuby and IronPython. So if someone passes you an object that was created inside of IronRuby, you can still invoke methods and get values from properties, because you can treat that object as a dynamic type. We can also invoke the Compute method here and pass in 2 and 5. Again, that's just like the code we had here, the effect is the same.
Creating Objects
The Reflection API also allows you to dynamically create types. This is done through the activator class. In this code snippet, we're going to use the LoadFrom static method on the assembly type to dynamically load a dll. This is part of the Reflection API too. plugin.dll then is not an assembly that we have referenced at compiled time inside of Visual Studio. Instead, we're going to dynamically load it at runtime just by looking to a certain spot on the file system and asking the runtime to load that assembly up. Once we had the assembly loaded, we can use the GetTypes method to find all of the types that are defined inside that assembly. And then the type object has a method GetInterface that we can use to ask, does this type implement ILogger? If it does, we'll use Activator.CreateInstance to instantiate an instance to that type. That will give us back a reference to an object that implements ILogger. Let's look at Activator.CreateInstance in Visual Studio. Here is an ILogger interface that defines one method called LogMessage. And there's a class ConsoleLogger that implements that interface. It has a constructor so that when this object is constructed, we're going to write out ConsoleLogger created to the console. And when someone invokes the LogMessage method, we'll write out the message to the console. Inside of the entry point for this application, we're going to look inside the current executing assembly. So Assembly.GetExecutingAssembly gives us a reference to the assembly that contains this code that we're currently executing. We're going to get a list of all the types that are inside of this assembly. We're going to find the ones that implement this ILogger interface. And when we find one of those, we'll use Activator.CreateInstance to create an instance to that object. We're going to assume using this version of CreateInstance that that object has a default constructor. There are additional overloads to create instance that allow you to pass parameters of the type require some additional information, and there are other Reflection APIs in place that allow you to query the constructor info for a given object to find out what parameters it requires. So you can use the Reflection API to discover everything that you need, then create an instance to that object. And now, we can treat it like an ILogger and invoke a LogMessage. Let's just take a quick look at this from the command line to see how it works. And you can see that the ConsoleLogger gets created, and then we log the message that just says Complete.
Emitting Code
I hope you've seen enough of the Reflection features to understand that Reflection is a very powerful capability to have in a C# application. But there is one additional feature I wanted to demonstrate, and that's the ability to dynamically create code. When you dynamically create code, you can construct new types dynamically, create assemblies on the fly, and even create individual methods. In this code snippet, we're going to create a new instance of a class named DynamicMethod. In the constructor, we're going to pass parameters that say this method is named HelloWorld, that it returns void, and it does not take any parameters. At this point, we're set up to start creating the instructions that this method needs to execute. And to do that, we're actually going to write some IL. We can do that through a class called the ILGenerator. We can get a reference to that from our dynamic method instance. And now, we need to start loading in OpCodes or Operation Codes. These are actual Microsoft intermediate language instructions that you could see if you decompelled a .NET program. So these are not C# expressions, these are not VB expressions, these are actual IL instruction. It's what you get inside of an assembly once the C# compiler runs. This first instruction is the IL instruction to load a string. And the second instruction is the IL instruction to invoke a method, to call a method. The method that we're calling, we get from a methodInfo object that we created earlier by finding the WriteLine method of Console. So this is going to be essentially the Console.WriteLine, and it's going to be the WriteLine that takes a string parameter. That's what we're passing in here with Hello, World. We invoke the call operation. At that point, we're all finish, so we'll return from this method and it's essentially complete at that point. To actually execute this code, we'll ask the DynamicMethod to create a delegate for us. So remember our discussion about events and delegates. Remember, delegates were those objects that are kind of like function pointers. They encapsulate a method that we can invoke through that delegate. And so, once we get a reference back to a delegate, we can simply apply the parenthesis, and invoke this dynamic method. So this bit of code, with the dynamic method, if we execute that, we'll see that it writes out Hello, World.
C# on the Metal
Earlier in this course and also in this module, we talked about the just-in-time compiler. We know the JIT compiler's job is to take IL instructions, like the ones we just saw in the dynamic method that we created, and transform those IL instructions into real native instructions that the underlying CPU can execute. Before the JIT compiler can do its job, however, we have to figure out which JIT compiler is going to be in place, because as it turns out, there's actually two versions of the Common Language Runtime. There's a 32 bit CLR that will run on 32 bit operating systems and 32 bit CPUs. And there's a 64 bit Common Language Runtime that will operate on 64 bit operating systems or on 64 bit CPUs. And the 32 bit CLR can operate on a 64 bit system because Windows has the ability to emulate 32 bit mode. This choice between a 32 bits or 64 bits is going to be made when your program is loaded by Windows, and it's influenced by some flags that are set inside of the executable that is being launched. It's essentially another form of metadata. And you can change these flags by setting build properties on your C# projects. If I switch over into Visual Studio and right-click on my project, I can come in to the Properties and then come in to the Build tab, and you can see here we have a platform target setting. This platform target setting can take one of several values. There is Any CPU, x86, and x64. There's also an Itanium option but that's rapidly becoming obsolete, so I'm not going to talk about that one much. Let's talk about what these other three options will do. If you set your platform target to be x86, that means when your application loads, it's going to be in a 32 bit process, it's going to use the 32 bit CLR and the 32 bit JIT compiler. If your platform target is x64, it's going to load in a 64 bit process with a 64 bit CLR. And just so you know, if you target x86 but your application runs on a 64 bit operating system, it's still going to execute, it's just going to execute in a 32 bit process, and that's going to be achieved through the emulation mode that's in Windows. The reverse is not true, so if you target x64 and then try to run that application on a 32 bit operating system, you're going to experience failure. This third setting AnyCPU, and this is essentially setting up your application so that if it's executed on a 32 bit operating system, it'll be put into a 32 bit process. And if it's execute on 64 bit operating system, it'll automatically be loaded into a 64 bit process. The default setting when you create a new project that's going to create an executable using Visual Studio is going to be x86. This is generally the safest mode, and remember that x86 can run both as a 32 bit process on a 32 bit operating system, and as a 32 bit process on a 64 bit operating system. So x86 can effectively run anywhere. If you know your targeting an application that's going to always run on a 64 bit operating system, you can set that to x64. One of the advantages that x64 gives you is a much larger addressable memory space. So if you have a very memory intensive application, you can take advantage of that additional memory. So x86 is the default platform for projects that create executables in Visual Studio 2010. The default for Class Library projects or projects that just create dll's and assemblies is going to be AnyCPU. AnyCPU will allow that class Library to load into either a 32 bit process or a 64 bit process. But the decision on 32 bit versus 64 bit, that's going to be made before the assembly load, so that's going to be made by the executable that's launching. There is one caveat about AnyCPU that I want to point out, and that is that if you change the platform for a project that is producing an executable to AnyCPU, that means that executable may load into a 64 bit process and run under 64 bits. But, if there are any 32 bit dependencies that your application needs, the process is going to fail, it's not going to be able to load a 32 bit Class Library into a 64 bit process. This can happen, for instance, if you reference any COM components from your application. So if you target AnyCPU, you want to make sure to test both on a 32 bit operating system and a 64 bit operating system just to make sure that that application truly is going to work in both environments.
COM Interop
When we are talking about build platforms, we mentioned COM, which is short for Component Object Model, and this was a technology that was fundamental to Windows for many years. Since .NET is the successor to COM, there is a lot of work put into .NET to make it interop with COM. That is, the ability to invoke COM components from your managed code from a .NET project. And also the ability to compile a .NET project and expose it to COM so that you can call into .NET code from COM. Making your C# code available to COM is not a topic that we have enough time to dig in to detail on, but I will tell you that the steps generally involved are to first mark up your C# code with interop attributes. These are attributes that are going to specify guids, and prog IDs, and interface identifiers, and all the metadata that COM needs to instantiate your component and to invoke behavior inside of it. Once all of your interop attributes are in place, you'll use a tool called the Assembly Registration Tool or Regasm.exe to take all of that information that you've compiled into an assembly and register that information in the registry in the places where COM expects that information to be. At that point, someone who's writing code in Visual Basic 6 or inside of a Macro, inside of Excell, all these places where people are accustomed to using COM components, they'll be able to instantiate your managed code through COM and be able to use it, and your code's going to be indistinguishable from a COM component that's written in C++ or Visual Basic 6. Working in the reverse direction is also relatively straightforward. When you add a reference to a project, there is a COM tab in that add reference dialogue. And that COM tab is going to contain a list of all the COM components in your system and you can add a reference to those COM objects. What Visual Studio will do is generate all the interop code needed for your project to call through to those COM components. As the .NET Framework has matured, there's been less and less of a need to interop with COM like this. In the early days of .NET, there were still a lot of features packed inside of COM that we just didn't have available in the .NET Framework using manage code. But as the Framework has grown and matured, a lot of the things that are available through COM are now available through .NET, so we don't need to use COM Interop. But you still might find this useful in some scenarios. Let's look at a quick demonstration of COM Interop. And we had to come in to the project and add a new reference. This time, I'm going to select my reference from the COM tab, and we're going to find the Messenger API Type Library. This is the type library or file that describes all of the COM components related to Microsoft Windows Live Messenger. The type library is actually embedded inside of msnmessenger.exe. And once I add this reference, I have the ability to create instances of COM objects that are inside of there. So for instance, I can create a new instance of the Messenger class. And that is in the MessengerAPI namespace. This Messenger class knows how interact with the Messenger program that's running on my desktop already, it knows I'm signed in, it gets to see all of my contacts. And there are various things I can do now. So for instance, I can hook up an event to OnContactStatusChange and see when my friends come online, or go offline, or mark them selves as away. Let's make some more space on the screen. This event gets passed-- two parameters. There's an objects parameter, and an enumeration MISTATUS that will tell us if they're away, or online, or offline. Sometimes, working with the COM API can be a little bit difficult because you'll end up invoking methods and just getting an object reference back. Sometimes, you need to go explore the documentation for a particular API to understand what these actual types are. The other thing you can do sometimes is just take a guess. So for instance, we can come in to this Messenger API reference which is all of the information that Visual Studio had to put together for us to call that COM component, it essentially generated the Interop layer for us. We can right-click on that and select View in Object Browser. And now, we can see all the classes and interface that are defined in that Interop layer that allow us to talk to that component. And I can guess that what we really have here is an IMessengerContact. And an IMessengerContact has a FriendlyName property. So I could come in and coerce this object into IMessengerContact, or I could just make this a dynamic object. And what that will allow us to do is do a Console.WriteLine on my contact's FriendlyName. We'll just rename that variable so it's a little clear. And what that dynamic keyword will do is allow us to get to that FriendlyName property without doing any typecasting or figuring out what the exact interface type is. At this point, we could just put in a Console.ReadLine so that the program will (inaudible) and run for a while. And then we can build it and run it. I already have an instance that's been running for some time, and you can see that it's tracking my contacts as they come online or go idle or go away.
PInvoke
Sometimes, the unmanaged code that you want to reach will be packaged into a COM component, but you may face scenarios where you want to reach some unmanaged code that was written in C or C++, and that code is not packaged into a COM components. It simply lives as a function inside of a Dynamic LINQ Library. Fortunately, there's a mechanism in .NET where you can invoke that unmanaged code. This is known as Platform Invoke or PInvoke for short. Using PInvoke, you could call into, for example, the Windows APIs that are implemented in dll files. The code snippet that we have on this screen implements a method called Beep. And what this method will do is invoke the MessageBeep function that is a part of the Windows API, it's been around forever. In order to invoke that method, we have to tell the C# compiler where this function lives. So we're telling the C# compiler, this lives in User32.dll, which is a Windows system file. It's installed when you setup Windows on your machine. And you can see there's a sort of function signature here where we're telling the C# compiler, this is a method that returns a boolean and it takes an unsigned N32 that describes the type of Beep that we want. This sort of information, by the way, the information that you need to describe how to set up a PInvoke, there's a great reference for this on the internet, it's on the site pinvoke.net. This is essentially a wiki where developers who have figured out the proper PInvoke signatures and types to use, they'll come in here and post when they have something figured out. For instance, we could come in to crypt32, crypt32.dll, and we could see what the dll import should look like for the CertCloseStore function. And we could copy and paste this into our program, and then we should be able to invoke CertCloseStore. Again, PInvoke was one of those mechanisms that was very important in the early days of .NET before the library matured. Fortunately, today, most of the stuff that we would need PInvoke for is now covered by the Framework. But again, you may find this useful in certain scenarios.
Summary
In this module, we've seen just how closely C# integrates with the Common Language Runtime, and how we can use a lot of the CLR features to our advantage. We've seen that we can use C# interop with COM components. We've seen that we can use C# to interop with native code. But I think the most important lesson in this module was about metadata. Metadata drives many of the features that are available to us. It enables garbage collection, it helps the JIT Compiler. And we can use metadata to our advantage too. We can use it with those Reflection APIs that allow us to query unknown objects, it allows us to create code, it allows us to activate objects. One of the greatest features of the C# language is just how well it works with the Common Language Runtime.
C# and Generics
Overview
Hi, this is Scott Allen of Pluralsight. And in this module, we're going to look at generics in the C# language. Generics were a feature that were added in version 2 of the C# that was released with .NET 2.0 and Visual Studio 2005. Let's start off this module by looking at the problem that generics are designed to solve and then talk about writing generic classes, generic methods, generic interfaces. We'll also see how to apply generic constraints which allow you to write more specific algorithms when you're writing generic classes. We'll also touch on other topics like covariance and contravariance with generics.
Why Generics?
A popular trick that you might see at a magic show is for a magician to pull a rabbit out of a hat. It's really impressive when they can pull more than one rabbit out of the hat. If we are writing some code in .NET 1.0 to simulate a magical hat, we could use a collection class like the ArrayList and we could add rabbits to that ArrayList that we can pull out later. The trick with the ArrayList though is it's not dedicated to storing one type of object like a rabbit object. It's designed to store any type of objects, so you just add object references into the ArrayList. And that means when you go to retrieve a rabbit, you typically need to do some type of type coercion. For example, you can pull a rabbit out of a hat and do some typecasting to coerce that reference into a rabbit. You can also check if any given element in that ArrayList is of type rabbit, and if so, then cast it. That will be a little bit safer. But the underlying problem is still fundamentally that we can add a string into that ArrayList. We can add any type of object into that ArrayList even though we wanted the design to hold just rabbit references. All of these casts and checks are really just annoying because they clutter up the code. It would be much nicer if we had a collection class that was dedicated to holidng only rabbits. That way, when we retrieve any object from that collection, they would already be typed as a rabbit.
Building Collections Without Generics
There were a couple of different approaches that we would take to create a strongly typed collection back before generics were a part of the C# language. One approach would be to create a class that derives from a built in collection class like the ArrayList class. That allows you to inherit all the features and functionality in that base collection type and that base collection type already knows how to allocate storage and manage object references and values in a collection. Inside the class, then, you could add methods or override methods that would ensure this collection to only going to receive objects of a specific type. For instance, an Add method that only takes rabbit references. You could also provide an indexer that already does the type coercion so that the client code doesn't have to. This provided cleaner code. You could construct a RabbitList, add some rabbits and then pull rabbits out of that list without any as or is or casting operators. The solution that I described is not without problems however. It's nice because I can walk up to a rabbit collection and using the indexer get a rabbit out of that collection without any casting. However, because I'm using ArrayList as a base class, I'm inheriting and therefore exposing some undesirable methods. For instance, the Add method that allows someone to put any object reference into this collection of rabbits. There's a couple ways to solve that problem. For instance, instead of deriving from ArrayList and using it as a base class, we can instead use a field inside of this class to hold things. And then inside of methods like Add and the indexer, we simply delegate those calls to list. Instead of base.Add, this could be _list.Add. We still have all the features of the ArrayList available to us, but we're not exposing anything inadvertently through inheritance. However, there's a bigger issue at play and that is that most applications don't need a collection for just one type, like a collection of just rabbits. Sometimes we need rabbit collections. And if we're working in the magic domain, we might also need a balloon collection. And if I tear this tab off and we look at these two classes closely, you'll see that they're mostly identical. All of the real implementation code is exactly the same. The Add method forwards to base.Add, the indexers using the indexer in the base class. The only thing that's really different in these two classes are the type names. This is using rabbits, this is using balloons. And what I've presented here is a very simple example, but you could see if we have a more complex type of collection that we're duplicating a lot of code just so that we can have strong typing. This is exactly the problem that generics are designed to solve. What we'll see with generics is that we can now implement a class and instead of specifying these types explicitly like rabbit or balloon, we can instead say here's a type parameter that a client has to use to specify the type that this collection is going to act on and then the runtime, the CLR is going to perform some magic so that we get all of the benefits both in strong typing and performance benefits of using an actual type like rabbit or balloon.
Using Generics
With the release of .NET 2.0 and C# 2.0, Microsoft introduced a new namespace into the base class library. The namespace is System.Collections.Generic. Inside of this namespace is a suite of collection classes that rely on generic type parameters. These collection classes essentially replace all of the collection classes that were shipped in the original .NET Framework in a system .colections namespace. One example is the collection list of T. When I talk about of T, I'm talking about T, the generic type parameter that you need to specify when you construct a new list. In this code snippet, we're constructing a list of T and that T is going to be Rabbit. That means that we want a list that can hold rabbit references. We don't want top put in string references or object references. We only want it to accept and yield back rabbit references. Essentially, generic type parameters allowed Microsoft to implement one version of this list class, so it's just a one bit of code, but we can use that in a strongly typed manner with any object that we choose. Generics allow code reuse with type safety. Whereas, previously, if we wanted a single collection implementation, we'd have to deal with object references because we wouldn't know what sort of object types that people would want to storing in that collection. With generics, the type can be specified using a type parameter that appears between the angle brackets. Again, there's only one implementation of this list. It's the same internal algorithms used no matter what type is used to instantiate that list. This snippet of code is using what we call the collection initializer syntax in C# that was new in C# 3.0. This is essentially adding three rabbit objects into that list. And now, we can retrieve them without any typecasting. So retrieving them-- we're retrieving them as rabbit references. In this last line of code in the snippet would actually force a compiler error. The C# compiler knows that the Add method of this particular object does not accept string references. It only accepts rabbit references. Let's take a look at using some of these generic collections. I have a using statement for Sytem.Collections.Generic and that means I can construct a new list. You'll see that IntelliSense is telling me that I want to construct a list of T where T represents the type of elements in a list. So I can say I want a new list of rabbit. One thing you'll notice is that I need to specify this both on the right hand side where I'm using the new operator because this is the exact type that I want to construct to a list of rabbit and it's also the type of my variable. It's not a variable type as list of T. It's a variable type as list of rabbit. We'll talk about this and the technical details a little bit later in this module. But at this point, I can begin adding rabbits into my list and you'll see that the Add method will only accept rabbits. Now, there are cases where you need multiple generic parameters. For instance, the dictionary collection, this takes two generic type parameters Tkey and Tvalue. Tkey represents the type of the keys in this dictionary. Let's say that's a string. And then TValue represents the value, the type of the values, so they're going to be in that dictionary. A dictionary is essentially like a hash table. It's a collection of name value pairs. But you can use anything for the key and essentially get fast access to some objects stored inside that collection based on its key. For instance, we can specify that we want a new dictionary of string and rabbit. And now, what I can do is I can add to that dictionary. I could add the key is going to be the name of the rabbit and then the rabbit object itself. ( Pause ) And when I want to retrieve a rabbit, I just need to specify that key. So I could say that I want from the rabbit's collection, I want to see if there is something named Fluffy. And if we have a couple thousand rabbits stored inside of here, that's a very quick look up to find that object with that name. And if it doesn't exist, we'll get an exception. But the important part to focus on here is the instantiation of this generic type. I need to specify two generic type parameters, the type of the key, the type of the value. So it's a dictionary of string and rabbit.
Generic Collections
Here are some of the other classes available in System.Collections.Generic. There's a HashSet of T. The HashSet of T represents a set that is a collection that doesn't contain any duplicate elements. Every time you add an object into this collection, it invokes the GetHashCode method on that object to compute the hash of that object and then it makes sure that there were no other objects inside with the same hash code. There's a List of T which we've already worked with and it's very much like an array but it can dynamically resize itself. There's no restrictions on duplicates. There's no restrictions on ordering. And there are methods available on the List of T that allow you to search and sort that list. There's a Queue data structure. The queue ideal when you want to add objects into the queue and then retrieve them such that the first object that you put in the queue is the first object that you get out, first in first out or FIFO as you'll see in some documentation. And there's also a Stack of T. A stack has push and pop operation. So you push an object in and then when you pop the stack, you get the last object that you pushed in to the stack. So it has last in first out semantics or LIFO. And there's also the Dictionary. You add in objects to a dictionary and specify their key. And later, it's a very high performance operation to be able to look up that object using its key value. Essentially, the dictionary doesn't have to traverse the entire set of objects to find the object that you're looking for by its key value. It can use hash codes to look things up very efficiently. Now, why should you be using System.Collections.Generic, the collections inside of that namespace instead of the ones in System.Collections like ArrayList? One obvious advantage is type safety and we've already talked about this. An ArrayList is essentially like a list of object, where T is object. You can put anything inside of there, but then you typically need to coerce it when you retrieve it. With a list of rabbit or a dictionary of string and rabbit, you can be sure that the only thing you'll get in there is a rabbit and the only thing you can retrieve is a rabbit. But there's another advantage and that is a performance advantage particularly when it comes to value types. Now, in a previous module, we talked about the difference between reference types and value types, and how value types sometimes need to be treated as objects and that therefore they get boxed. They go through this operation known as boxing. Let's take a look at the performance implications of boxing. Inside of the demo project, I'm going to use the Stopwatch class from the System.Diagnostics namespace to measure the amount of time it takes to execute a piece of code. The Stopwatch class can use a high resolution timer that's available in the operating system. And in this case, what I'm going to measure is the amount of time it takes to store and retrieve some integer values in an ArrayList. In this case, we're going to store 10 million integers in that ArrayList. And then we're going to retrieve each integer value that we place into the ArrayList. We're not going to anything with the value. Just pull it out of the list. And we're going to see how much time that it takes. Then we're going to measure the same piece of code, but this time, instead of using an ArrayList, you use a List of int. We're going to store 10 million integers and retrieve 10 million integers. Let me press F5 and let this run and we'll see how long it takes. Now, we're complete and we can see that the ArrayList took just over 4 seconds to execute, 4,178 milliseconds. Meanwhile, a List of int only took 679 milliseconds, so less than a quarter of the time. And it's not that the code inside of the list class is that much more efficient. It's because the ArrayList stores object references. And in order for that integer value to be stored in the ArrayList, it has to be boxed, so an object has to be created on the heap, the integer value is copied onto the heap, into that object. And that's relatively extensive operation when you do it 10 million times. And then each time you want to retrieve one of these integer values, it must be unboxed. List of int, on the other hand, works a little bit differently. And to understand why, we have to understand how the runtime works with generic types. The CLR in the .NET runtime understand generic types. And essentially, when you construct a generic type like a List of int or a List of float or a List of date time, the CLR is actually going to generate a specialized generic type at runtime for that value type. And right now, I'm just talking about value types. So a List of int will generate a slightly different specialized type than a List of date time, because they're two different value types. But what that means is that the list of integers is actually storing integer values that doesn't need to box each integer as we add it to the list. Instead, the list can pre-allocate a bunch of memory on the heap and just start cropping integer values inside of there instead of allocating each one as an object. Now, generics work a little bit differently for reference types. The first time you construct a generic type with the reference type, like a list of rabbit or rabbit as a class definition, therefore, to referenced type, then the runtime creates a specialized generic type with object references that will work for any type of reference type. So a list of rabbit and a list of balloon will both use that specialized generic type that's created by the runtime. If you're familiar with how templates work in C++ which were used to some of the same effect that generics are used in C# to create these type safe collections, then you'll realize that that is a bit of a savings over the C++ approach. The reason the CLR treats reference types and value types differently when it comes to generic type parameters is that with reference types, pointers are always the same size. In sense, we're always dealing with pointers, ultimately with reference types, then we just need one specialized version of the generic type. But when it comes to value types, an integer has different storage requirements than a float or perhaps a date time. So in those cases, the CLR is generating a specialized type that is very efficient for that specific value type. But the end result is that you should always be using generic collections not just for the type safety but when you're working with value types, there can also be a performance benefit.
Generic Parameters
So far, we've been looking at generic types from the consumer's point of view. That is, how do I consume and use and construct the generic type that someone else has implemented? Now, let's turn our perspective and look at how we create a generic type. When you create a generic class or a generic struct, you specify the type parameter in between angle brackets. This type parameter, name by convention in .NET always start with the capital T. You can leave it as just a capital T which just means some type, or you might want to be a little more explicit particularly if there are multiple type parameters. For instance, with the dictionary, we had two Generic type parameters, TKey and TValue to represent the type of the key and the type of the value. In this class, the MagicHat will just going to hold various magical objects. We're just going to have a MagicHat of T. And now, the client, when they instantiate a magic hat, they have to specify what that T is going to be. Is it going to be a rabbit? Is it going to be a balloon? Is it going to be something else? Once I've done this, I can now use T anywhere throughout the rest of my class definition to represent this type whose specification I deferred until runtime. So when I need to specify the parameter to the Add method, the type of the parameter, it's going to be T. When I need to construct a list that will hold these magical items that are being added to the magic hat, I can use the T there. In many ways, you can think of a generic class like this as more of a blueprint for specific types that are going to be instantiated by the runtime. So MagicHat of T isn't something that you can instantiate. But a MagicHat of Rabbit or a MagicHat of integers or a MagicHat of balloon, that's a very concrete type. And the rabbits and the balloons and the integers are all going to be substituted for this generic type parameter when that class is instantiated. Let's take a closer look at implementing this MagicHat class in the demo project. And let's say that instead of behaving like a list which is like the code we had in this slide, we wanted the hat to behave more like a queue. So the first thing that you put into the hat is going to be the first thing that you pull out. And you really can only put things in and pull things out. There's no random access like you have with a List of T. One way to do that would be to derive from the Queue class itself. So we could say I want to derive from a Queue of T. If we try this, the C# compiler is going to be unhappy. It's essentially telling us I don't know what T is. Well, of course, we need to specify that at runtime. It wouldn't make any sense to derive from Queue of Rabbit. That's legal. That makes the C# compiler happy. But essentially, what we have is a hat that can only contain rabbit objects. So instead, I'm going to put the T back in place and I'm going to add a generic type parameter to the MagicHat class that is also a T. And now, when the client instantiates MagicHat and they pass a type for that parameter, it literally is a place holder. So even with the queue, the runtime is going to know that a MagicHat of Rabbit derives from a Queue of Rabbit. T is a placeholder that's going to flow through the rest of the class. Now, with that little bit of code, I've already constructed something that is usable in a sense that I can now construct a MagicHat of Rabbit. I can use the Queue operations that I've inherited to put rabbits into the hat and pull the first one out, write out its name. So this would be one approach to building that class and it also demonstrates how you can use inheritance to inherit from a generic type. You either need to have a type parameter that you're going to pass along to that generic type or you need to specify a specific type there. We'll return to that topic again just a little bit later. But let's say that when I'm thinking about magic hat, I'm not really thinking about queuing objects and dequeuing objects. I'm thinking about putting things into the magic hat and pulling things out of the magic hat. In that case, we can implement the class a little more like we had on the slide. It's a MagicHat of T, doesn't derive from anything, but it has a Put operation where T is used, just the type of parameter to pass something in. And T is used as the return type of this Pull method that's essentially going to pull something off of the queue and return it. And now, we've hidden that queue behind the scenes of the magic hat. Now, the code that we have that uses that hat uses terms that might be a little more understandable to a magician. It's how they're going to describe their operations. They're saying I'm going to put something into the hat later in my act. I want to pull something out. And the beautiful thing here is that our generic type parameter, the rabbit has flowed throughout that class so that the Pull operation is strongly typed and returns an object of type rabbit. As a lead into the next slide, I want to point out that so far we have not done anything with these parameters that are being passed in or the types that are being returned. In other words, all we're doing is we're taking this parameter passing it onto the queue that knows how to store a rabbit or a balloon or whatever you have. But let's say that we actually wanted to invoke some operations on these parameters that are being passed in. In that case, you'll notice that the parameter is being treated as type System.Object, because at this point, the C# compiler doesn't know what that type is going to be. It doesn't know it's going to be a rabbit. So it's using the lowest common denominator which is System.Object that everything will inherit from. Of course, this isn't very useful because typically when you got to the trouble of creating a generic type, it's because you want to abstract some algorithm or process that's going to invoke some behavior or change some state on these things that are being passed as parameters so that you're going to compute and return. We'll see how to do this in the next slide when we start talking about constraints.
Generic Constraints
By default, there is no constraint on the type that a client can use when they instantiate a GENERIC type. So a MagicHat of TAnimal could be constructed as a MagicHat of int. As I mentioned in the previous demo, this isn't very useful when you want to perform specific operations on the types that you're constructing this class for. And this is where a generic constraints come in to play. generic constraints allow you to constrain the type parameter that a client can use when they're constructing an instance of the class. For instance, you can force the type to be a struct. You can force the type to be class. You can force the type to have a public default constructor. You can also force the type to implement a specific interface or derive from a specific base class. For instance, let's suppose we have the interface IAnimal that a bunch of animal classes will derive from, like the Rabbit class that we have. And this interface says that anything that implements this interface needs to implement a method called Feed. We can constrain the type that's used to construct a MagicHat to something that implements IAnimal using this syntax. So you say where TAnimal colon and then the constraint. In this case, it's the name of the interface. What this allows us to do inside of the generic type then is then we can then treat anything that is of TAnimal as something that implements IAnimal. It doesn't have to be just a System.Object anymore. It can be an IAnimal. So we can store a List of TAnimals. They're all going to implement IAnimal. And that means we could implement a method called FeedAll that's going to loop through all the animals that we're storing and invoke that Feed method. You can use multiple constraints. And basically, you'll need at least one constraint whenever you want to perform any type of operation that's not supported by System.Object. Let's take a look at constraints in our demo project. I want to start off with a rather contrived example, but let's add a constraint to our MagicHat that says where T has to be a struct. Essentially, we're telling the C# compiler, a client is only allowed to instantiate MagicHat using a value type. If I add that constraint and I do a build, we'll get a compiler error. And the error is on this line of code that's trying to construct MagicHat using a reference type which is the Rabbit class. So you can see how that constraint woks. But let me remove that constraint. We'll talk about some more practical scenarios. First, I'm want to talk about null references in generic types. It's perfectly legal for me to compare newThing and see if it is a null reference. And let's say only if it is not equal to null then you can add it to the queue. And this is perfectly legal code. You might say, but wait a second, what if T is a value type? What if it's a MagicHat of int and int can never be null? But it turns out, in C# code, it's perfectly legal to compare, say, an integer or some other value type to null. The C# compiler will happily build this. It will give me a warning saying that this expression is always false since a value type of int can never be null. But it is the legal code that compiles nonetheless. So it's perfectly legal to compare a T to null. It's a different scenario if I want to assign null to T. Let's take this Pull method for instance. The default behavior of a queue is to throw an invalid operation exception if you try to dequeue an empty queue. Let's say we want to prevent that scenario. So we'll say if the queue is empty, we'll return null instead. If I do a build, the C# compiler is going to jump in and say I'm sorry but I cannot assign null, I cannot return null for this T and I can't assign null to T because it might be a value type. What happens if we have a MagicHat of int? I cannot assign null to an integer. Now, there's a couple of ways to solve this problem. One is to use the default keyword which we'll talk about a little bit later. But another way is to say that T has to be a reference type. So my constraint is where T is a class. T always has to be a class. It has to be a referenced type. If I do another build, the C# compiler is happy again. So that's the class constraint. Let's take a look at another scenario. Let's say that I wanted a method that would automatically populate my MagicHat with some magical items. So we'll have a method called Fill. We'll set up a loop from 0 to less than 5. And now, I want to construct a new T. How do I construct a T when I don't know what T is going to be? Well, again, I can use T as a placeholder and with a new operator to say I want a new T. And then with the queue, we will add this newThing to the queue. But at this point, what C# compiler is going to be unhappy and say I'm sorry but I cannot create a new instance of because I'm not sure it's going to have a default constructor. That is, a constructor with no parameters. In order to enforce that, I can add new constraint. So we have a class constraint in it a new constraint. And if do a build, the C# compiler is happy again. And now, let's take this one step further. Magicians like to make things disappear. So we will add a Disappear method to our MagicHat. And not only will be empty out the queue by looping and dequeuing items until the queue is empty, but we also want to invoke a Disappear method on each thing that we pull out of the queue. Make sure everything disappears. Of course, at this moment in time, the C# compiler has no guarantee that T is actually going to have a method called Disappear. So how can we invoke this method when we don't even know what type is going to be used to instantiate MagicHat? Well, it just so happens that I have an interface defined called IAmMagical. And anything that is magical will need to implement a method called disappear. And a rabbit implements IAmMagical and a balloon implements IAmMagical, and essentially, everything that I want to put in a hat is going to implement IAmMagical. And that means I can add a constraint telling the C# compiler that this type can only be constructed using reference types that implement IAmMagical and have a default constructor available. And with those three constraints in place and they can-- I can now do a build and the C# compiler is happy with all this code. Instead of an interface, I could also use a base class name here. And I could say that everything used to instantiate MagicHat must be derived from this base class that implements a Disappear method, but the interface I'm more comfortable with.
Terminology
Before we continue, I wanted to explain a couple of the terms that you might come across in the documentation for generics, or even sometimes in the API or the error messages that you make get when working with generics. First is the term unbound generic type. An unbound generic type is a generic type whose type parameters have not been specified. In other words, we're talking about List with angle brackets but there is no T inside. You can use this in reflective code and with the type of operator to get back a reference to a System.Type object that you can then use to create a constructed generic type. If you ever come across this syntax, just think unbound generic type. It's a blueprint that you can use to create other types. The opposite of an unbound generic type is a constructed generic type that is always going to have type parameters. But a constructed generic type comes in two forms. First, there is the open generic type. An open generic type has a type parameter that still needs to be substituted, for instance, List of T. And that's different than a close generic type where the type parameters have been specified, for instance, a List of int. If you are working with an object that has been constructed from a generic type, then that object is an instance of a closed constructed type. So it's something very concrete like a List of integers. List of T is something that we cannot create until we specify a type and the unbound type is also not something that we can create without some additional information applied to it. One place where this is significant is when dealing with inheritance. When specifying a base class, that base class can be a generic type but it can never be an unbound generic type. So that's to be a constructed type. But it can be open or closed in the case where the class you're defining is also a generic type. In this example, we have the open generic AnimalCollection of TAnimal inheriting from ICollection of TAnimal. Of course, this only works because the type argument for ICollection is being provided by AnimalCollection. These are both TAnimals, so this is going to work. For a non-generic type like RabbitCollection, I can only inherit from a closed generic type. So ICollection of Rabbit, that's a closed constructed generic type. I cannot use a type parameter here like ICollection of T because there's no way for the client to pass that parameter along. Trying to inherit from an open generic type here would be an error. Let's try to make this terminology a little more concrete by looking at some sample code that's going to use reflection to manipulate a generic type. Inside of this CreateHat method, we're using a type of operator to construct a System.Type that represents the unbound generic MagicHat. There are many things that you can do with the System.Type reference. We looked at some of those in the last module when we talked about Reflection. And one of the things that you can generally do is pass that System.Type reference into Activator.CreateInstance to construct an instance of that type. But let's run that code as it stands right now to see what happens. And we'll se that we get an exception because Activator.CreateInstance cannot construct an instance of an unbound generic. Remember, an unbound generic is just a blueprint that is used to create the special classes, the specialized classes that are constructed generic types. So let's stop debugging and look at one way to fix this which would be to specify a closed generic type, MagicHat of Rabbit. And if we run this application now, we'll see that everything works and the object that we get back from the CreateHat method is indeed a MagicHat of Rabbit. Of course, this isn't very useful because if you've gone through the trouble of writing code using reflection to instantiate a type, you don't have the liberty of hard coding the type inside of here. It's typically going to be some sort of parameter that's passed. So let's go back to the unbound form and remove Rabbit. And instead, what we'll do is we'll pass a type that's going to be used as the type argument. And remember that an unbound generic is just a blueprint for making other generic types. And in fact, there's an API available or on System.Type called MakeGenericType. You just need to pass in the type arguments. And in this case, we just have one. Just pass in the type arguments that are going to be used to construct that new generic type. Now, when we invoke CreateHat, we can pass in the type argument. Now, with a little bit of typecasting, we can now make this behave as a MagicHat of Rabbit. ( Pause ) Now, let's run this program and you can see that everything worked as expected. Now, the code that we're looking at is a bit esoteric. This is not something that you run across in day to day business development. But I did want to make you aware of it in case you need to write some reflection code using generic types. And another scenario where sometimes comes into play is when you're using an inversion of control container. Quite often, you have to register unbound generics with an IOC container because it's the container that's going to apply these type arguments to make the actual generic types that it will instantiate for you.
Generic Methods
So far, we've seen that we can define a generic type. That is a type that requires type parameters. We can also define generic methods, that's a method declared with the type parameter. For example, FindByType of T. You can add type parameters to instance methods and static methods. And just like a generic type, you can also specify constraints on the type parameter. Once we've put the type parameter into play, we can then use it throughout the method and even to specify the type of the return value. What this method is going to do is look through a collection of animals to find animals of a specific type. You'll notice, we have another generic type parameter here, TAnimal that wasn't' a type parameter on our method, so it must be the type parameter that was specified as part of the class that this method is inside of. So you can see there are actually two type parameters in play inside of this method. One defined by the class, and you can imagine this might be a low level abstraction like IAnimal that all the animals implement. And then we have the type parameter T which is probably a concrete type that someone is searching for in the collection like rabbit that would implement IAnimal. In an earlier module, we talked about a method signature. The signatures were employed when it came to method overloading that is providing multiple implementations of a method that have the same name but the method signature differs. And remember, the method signature consists of the method name plus the types and the number of parameters. Well, it also consists of any type parameters that are part of the method. So the T here is part of a method signature and FindByType of T would be different than FindByType that doesn't take a generic type parameter and it will be different than FindByType that takes two type parameters. Generic methods are extremely useful in certain scenarios because they can reduce the amount of clutter in client code. So I'm about to demonstrate this CreateHat code can be cleaned up. Right now, it requires a type of operator and some typecasting to get anything useful out of the CreateHat invocation. And that's partly because CreateHat doesn't have any idea what type of object it's creating inside of here. So it has to return object reference and that's going to require some typecasting. But you can usually identify a good candidate for a generic method whenever you see that one of the method parameters is a System.Type reference, because instead of passing it as a method parameter, you can pass that type as a generic type parameter. So let's change our CreateHat to use a generic parameter instead. So this is going to become CreateHat of T. And now, we no longer need this type argument parameter. Instead of using type argument, we can say that we want type of T and we can even go one step further and we can say that this is going to return a MagicHat of T. Of course, that means we need to do our coercion here inside of CreateHat. And that's okay, because it's going to make the client code prettier. But before we can change the client code, you'll notice that we have a compiler error. And this is because of all the constraints that are in place on MagicHat. We need to apply the same constraints inside of this method because the C# compiler knows that T has to be a class, has to implement IAmMagical, and it has to have a default constructor. One of the drawbacks to generic constraints is that once you put them into play, they generally ripple through your code whenever you're going to use that type. With this new implementation of CreateHat, however, our client code becomes a lot easier. We can just say CreateHat using a Rabbit and invoke that method and we don't need to use any typecasting now. Our program builds and our client code is a lot easier to read. And this is a great example of how generic type parameters can clean up code that's using a lot of typecasts.
The default Keyword
Earlier in this module, I alluded to the default keyword. The default keyword is something you can use to assign a default value when you don't know if the type you're going to be operating on is going to be a reference type or a value type. For example, in this FindByName method, we might be looking for a specific animal inside of collection of animals. But what happens if we do not find the animal that we're looking for? Let's assume that we don't want to throw an exception but just return a default value. We could return a null reference, but as I demonstrated earlier in this module, you can only return a null reference when you have a constraint that says your generic type has to be a class. And let's say that you wanted to work with both reference types and value types. In that case, returning null will not work because you cannot assign null to a value type. Value types each have their own default values. For most numerical value types like integers and longs, the default value is going to be a zero. But each value type can be a little bit different. And this is where you can just use the default keyword passing your generic type parameter and the C# compiler and the runtime will work together to produce the correct default value for whatever type that you're working with. If TAnimal is an int, this would return a zero. If TAnimal was a reference type, this would return a null reference.
Generic Interfaces
In addition to generic classes, generic structs and generic methods, you can also define generic interfaces. These are just interfaces that will take a type parameter. There are many examples of generic interfaces in the .NET Framework. For instance, IEnumerable of T is an interface implemented by every strongly typed collection in .NET. IList of T is implemented by all the collections that provide random access. And IComaparable of T is an interface that you can implement whenever you want to provide a type specific comparison method. That is, the CompareTo method. Sorted collections will often require that you implement this interface so that they can compare two objects and keep them properly ordered in the collection.
Generic Delegates
C# also supports generic delegates. That's a delegate that takes one or more type parameters. These are great for defining events. For instance, let's say we wanted to raise an event that would include an AnimalAddedEventArgs or raise this event whenever a new animal is added to some collection. Before generics, we'd have to go out and define a delegate type that says here is a delegate that takes two parameters when it gets invoked, an object parameter that will represent the sender, and an AnimalAddedEventArgs parameter that represents the event arguments. With generics, there's an EvenHandler of T where we can simply specify what the argument types are going to be. So EventHandler of AnimalAddedEventArgs will make this an event on a class. And now, clients can subscribe to the AnimalAdded event. We can also raise the AnimalAdded event and pass along some AnimalAddedEventArgs. The base class library also defines Func, Action and Predicate. These delegates become very important when you're programming with LINQ. Many of the LINQ operators are operators that accept a parameter that is the delegate type. For instance, the Where operator in LINQ. It knows how to filter things, but it doesn't know exactly what you're looking for, so you pass in a Func that will be invoked for each item in an in memory sequence to see if that is the item you were looking for or if that is an item that you want to exclude as the Where operator does its filtering. For more information on these generic delegates, you can look at the LINQ course in Pluralsight on Demand.
Variance
C# 4.0 introduces some new behavior with generics. Let's take a look at the sample code that is creating a List of Rabbit and then passing that to a method, ProcessAnimals. And let's say that ProcessAnimals expects a parameter of type IEnumerable of IAnimal. This would create a compiler error if you're building this with C# 3.0 in Visual Studio 2008. This is because collections are invariant in C# 3.0. And this compiler error is really unexpected because any place where we have a rabbit and we assume that rabbit implements an IAnimal interface, any place where we have a rabbit, we can pass that rabbit to nay method that takes an IAnimal parameter. This variance in the parameter treating a rabbit as an IAnimal is essentially what gives us polymorphism in C#. It's one of the basic tenants of object during their programming. But as soon as we begin using rabbit as a generic type parameter, we lose this capability because of the invariance in generic collections. In C# 4.0, this code will work, but there are some restrictions. The T in this case has to be a reference type and it only works with some specific generic interfaces such as IEnumerable of T, IEnumerator of T, IQueryable of T and IGrouping. IQueryable and IGrouping of TKey and TElement are two interfaces that are popular with LINQ.
Summary
In this module, we saw how generics in the C# language can be used to create type safe abstractions. Although generics are primarily used for creating type safe collections, we've also seen how we can have generic structs, generic interfaces, generic methods and generic delegates. When you are implementing code in generics, quite often, you'll need to apply some constraints. And we looked at these constraints. You can force a type parameter to be a reference type or a value type. You can also force it to have a default constructor to implement some interface or to derive from a specific base class. Once you apply these constraints, you can write more specific algorithms inside of your generic code. Generics are a great feature in C#, and sometimes I wonder how we ever live without them.
Default and Named Parameters in C# 4.0
Default and Named Parameters in C# 4.0
Hi, this is Scott Allen with Pluralsight. In this short screencast I want to introduce you to two of the new features in C Sharp 4.0, default parameters and named parameters. So first we'll see how to implement named parameters and how they work, and also default parameters and I want to show you how these things can be useful in writing everyday code. Let's jump into Visual Studio 2010 and see how these features work. Now keep in mind I'm using Beta2 Visual Studio 2010 so the user interface might look a little bit differently when the final version ships, but these C Sharp concepts should remain the same. I'm going to create a new console mode application and then I'm just going to paste in some code that I want to use. This code is going to generate a message and the implementation isn't really that important but notice that it does take a nullable date time parameter. If I'm writing the client code that wants to invoke that method, I have two options. I can either pass in a null for the date time, or if I have a date time value available, and I'll just use datetime.now, I can pass that in and presumably that method will generate a different message for me. What bothers me is someone who is writing this code to invoke that method is this null parameter, because there's really no name, there's no indication of what that parameter is going to do. It would be nice if the person who was implementing this method provided an overloaded version of generate methods that just took no parameters and took some default behavior. That to me is a little bit cleaner than just passing in some nameless null value as a parameter. But, up until C Sharp 4.0 in order to pull that off, I'd need a second generate message that took no parameters. All we've done so far is create an area in our program, the C Sharp compiler will be unhappy and say generate message there's no overloaded version that takes zero arguments. But what I'm going to do is come to that generate message method and I'm going to add an optional attribute. The optional attribute lives in the System.Runtime.InteropServices.namespace and I'll explain why that is before we are finished with the screencast, but I'm going to add a using statement to bring that into scope, and you'll see a couple things have happened. The C Sharp compiler is happy with this optional attribute, and the C Sharp compiler is also happy with generate message. And we could build this program now and we could run it and everything would be happy. So what happens when you add an optional attribute is that if the caller doesn't pass a value for this parameter that's been decorated with optional, you'll have a default value for that type. That means for reference types like a nullable date time, the value will be null. For value types like integers and floats and so forth, the value will be the default value all bets off for integers and longs it would be a zero. If you don't like to use the optional attribute, there is another syntax you can use and also provide a default value, the default value that you want used, I could simply say date time equals null and that's going to provide the same effect as using that optional attribute in addition, I no longer need that namespace. C Sharp compiler is still happy. We can still compile and execute this code. Keep in mind there's a couple limitations here. The default value that you provide has to be a compiled time constant. It has to be something the compiler is going to bake into the assembly. It has to be something that the compiler can compute. So for instance if I wanted to default that date time to datetime.now, the C Sharp compiler is going to be unhappy and give us an error. The default parameter value must be a compiled time constant. Null is a compile time constant. I could also have another parameter like foo and give it the value three, and again that's a compile time constant that the compiler can work with. But if I want to base the default value on some expression, I'm going to have to put that in the method body itself. Something else to be aware of is that the default parameters have to appear after values that do not have a default. So, for instance, if I don't have a default value for this integer parameter foo, I'm going to have compiler error. Optional parameters must appear after all required parameters. Let's remove that parameter, and now the compiler is happy again. When I'm writing the code to invoke a method how do I know what parameters have default values? One way to know would be to go to the definition for that method but some of these methods will be in third party libraries and fortunately the Intellisense window will tell you. So in this case we see that we do not need to pass in that date time and if we don't pass it in, the default value is going to be null. That Intellisense would appear both when we use this syntax for defining the default value and also if we were using the optional attribute, we would see the data time default's null. Now that we see how optional parameters work and how we can specify default values, let's move onto another scenario, the named parameters. So first I'm going to add another parameter to generate message. We'll call it use uppercase and I'll provide a default value for this also. It's going to default to the value false, and presumably what generate message would do is if someone wants uppercase, they would pass in a true value for this parameter and generate message would make sure that the entire message is in uppercase. Now, notice the C Sharp compiler is still happy. I can call generate message and not pass any parameters, in which case we'll get a null and a false value. Or, I can call it and pass just a date time value and the uppercase will default to false. But let's say that I want to call generate message and I want to use the default time value for this method, but I want to specify that use uppercase is going to be true. Well, one way I could do that is I could see that the default value here is null, so I'll explicitly pass in the null, then I'll pass in the true, and there's a couple reasons why this isn't really working very well. First of all if I'm just reading through this code and I see someone invoking a method and passing a null and true, I have no idea what those parameters really represent. What is true? What kind of flag is that toggling? And what we might have here as a common use case where someone wants to generate an uppercase message, but the first parameter they just want to use the default value all the time. This is where the name parameters can come in useful and what I can do here is I can say that for the use uppercase parameter, I want to override the default value and I want to explicitly pass is a value of true. Then we can see that the C Sharp compiler is still happy with this. It's going to generate the code to invoke generate message, passing in a true value for use uppercase, but using the default value for the time parameter. And I could use the same syntax here if I thought it made my code more readable. I could specify explicitly that the time is going to be datetime.now and I could also explicitly specify a value for use uppercase, true or false. One of the ways I plan to use this feature is the way I've shown you just here. When I have a situation where the parameter itself is not very descriptive, I'm going to decorate it and use a named parameter so that later when I'm reading the code, I can see that here's a value true and it's going to toggle some uppercase flag. Hopefully you're seeing how optional parameters and named parameters can increase the readability of your code and sometimes make an API easier to work with. But there's a specific scenario where these two new features really shine and that is if you're doing any Office development with Visual Studio and C Sharp. Visual Studio allows you to create a project, an Office project, to create Excel add-ins and workbooks and templates, and not just for Excel, but also for InfoPath, Outlook, PowerPoint, Visio, and Microsoft Word, and you can do this for either Office 2010 or Office 2007. But one of the problems that you may have encountered in developing for Office is that the Office API is still mostly a COM API. And it's well suited if you're writing Visual Basic or VBA code but with C Sharp it's been a little bit painful. Let me give you an example. Here I'm picking a range out of an Excel workbook, and now I want to do some things with this range. For instance, I might want to check the spelling inside this range. And you can see check spelling takes four parameters. In previous versions of C Sharp, I would have to specify a value for every parameter this method expects. And some of the Office API's take more than ten parameters and you really only want to set one of those parameters. So, for instance do I want to use a custom dictionary, no, so I'm going to pass type.missing. I don't want you to ignore uppercase, I don't care about that, I'll pass type.missing. I don't want to use auto suggest. Spelling language. Let's say that out of these four parameters maybe I did want to specify a value for ignore uppercase, I wanted to make that true explicitly. I can do a build and the C Sharp compiler would be happy with that code in both C Sharp 3.0 and C Sharp 4.0. But if you do enough Office development you'll soon find that your code is just filling up with type.missing everywhere, because you have to specify something for each of these parameters. Well you'll notice in the Intellisense now that there are default values specified for each of these parameters. They've already been specified as type.missing. So I could invoke just range.checkspelling and the C Sharp compiler will be happy with that. All the defaults will be used. Or I could go in and specify a value for a specific parameter like ignore uppercase. We'll pass in a value of true. These named parameters and default values will be a huge boom for productivity and code maintainability and Office plug-ins. Let me summarize what we've seen in the screencast. We've seen that optional parameters can make an API easier for a caller to use because they don't need to explicitly pass so many default values into your API and as someone who is creating an API for an object or for a framework, you'll probably end up writing less code because you don't need to create as many overloaded methods that have all the different parameter combinations. You can do that using the optional attribute on a parameter or by simply saying parameter equals and give it a default value right in the parameter list. We saw that name parameters can also be useful. When I'm invoking a method I can simply say parameter and a colon and provide the value for that parameter. That makes my code more readable in many cases. And finally, if you're going to be doing any Microsoft Office development with the C Sharp language, you're going to find that these new features are invaluable and they're going to dramatically increase the readability and maintainability of your code.